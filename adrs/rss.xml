<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>go-cf-api Blog</title>
        <link>https://pages.github.com/go-cf-api/adrs</link>
        <description>go-cf-api Blog</description>
        <lastBuildDate>Fri, 03 Sep 2021 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Use Docusaurus to document our project]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - Documentation Framework</link>
            <guid>ADR - Documentation Framework</guid>
            <pubDate>Fri, 03 Sep 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: proposed]]></description>
            <content:encoded><![CDATA[<ul><li>Status: proposed</li><li>Deciders: <a href="https://github.com/FloThinksPi">Florian Braun</a></li><li>Date: 03.09.21</li></ul><h2>Context and Problem Statement</h2><p>We want a documentation page in which we provide documentation from different sources:</p><ul><li>Manually written documentation</li><li>GoDoc generated documentation from go code</li><li>API Documentation from a swagger/openapi spec</li><li>ADRs are nicely presented</li></ul><p>We want to have a nice page for it as when going public with this project, a good (single)entry point for people to look into the project is essential.</p><h2>Decision Drivers</h2><ul><li>Having the ability to have different sources of documentation, generated and manually written ones.</li><li>Being able to statically deliver the documentation (e.g. via GitHub Pages)</li><li>Nice Look</li><li>Easy to write docs in</li><li>Being able to use Continuous Delivery to serve the docs.</li></ul><h2>Considered Options</h2><ul><li><a href="https://docusaurus.io/">Docusaurus</a></li><li><a href="https://jekyllrb.com/">Jekyll</a></li><li><a href="https://www.mkdocs.org/">mkdocs</a></li></ul><h2>Decision Outcome</h2><p>Chosen option: &quot;<a href="https://docusaurus.io/">Docusaurus</a>&quot;, because it was easy to use, produces very nice results, has the most features and seems to be widely used.</p><h2>Pros and Cons of the Options </h2><h3><a href="https://docusaurus.io/">Docusaurus</a></h3><ul><li>Good, because it has a modern/nice look.</li><li>Good, because it has a plugin system which extends functions and delivers e.g. swagger/openapi support.</li><li>Good, because it is based on react and one is able to integrate own complex pages with that if one wants.</li><li>Good, because it has a build in deploy mechanism to deploy into a second branch on the same project.</li><li>Good, because it brings nice to have / advanced features for the future like versioned docs or multi-language support.</li></ul><h3><a href="https://jekyllrb.com/">Jekyll</a></h3><ul><li>Good, because it is integrated into GitHub Enterprise. They will generate the page regularly for you.</li><li>Bad, because it has few functionality. Hard to get e.g. Swagger/OpenAPI Docs to Display.</li><li>Bad, because i diskliked the themes/page design in general.</li></ul><h3><a href="https://www.mkdocs.org/">mkdocs</a></h3><ul><li>Good, because it has a plugin system which extends functions and delivers e.g. swagger/openapi support.</li><li>Bad, because it doesn&#x27;t offer an implementation of collectors to register multiple metrics at the same time</li><li>Bad, because i diskliked the themes/page design in general.</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Use client_golang prometheus library to expose metrics]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - Prometheus Framework</link>
            <guid>ADR - Prometheus Framework</guid>
            <pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: accepted]]></description>
            <content:encoded><![CDATA[<ul><li>Status: accepted</li><li>Deciders: <a href="https://github.com/will-gant">Will Gant</a> and <a href="https://github.com/iaftab-alam">Aftab Alam</a></li><li>Date: 20.08.21</li></ul><h2>Context and Problem Statement</h2><p>We want our PoC to expose prometheus metrics to be consumed by a visualization dashbaord, e.g,. Grafana, and also to benchmark peformance against the exisitng Cloud Controller.</p><h2>Decision Drivers</h2><ul><li>A metric system which can be easily extended with custom metrics to allow comparison with the performance of the existing Cloud Controller</li><li>Community support, solutions should be a broadly adapted technology.</li></ul><h2>Considered Options</h2><ul><li><a href="https://github.com/prometheus/client_golang">client_golang</a></li><li><a href="https://github.com/VictoriaMetrics/metrics">VictoriaMetrics</a></li><li><a href="https://github.com/poblish/promenade">promenade</a></li></ul><h2>Decision Outcome</h2><p>Chosen option: &quot;client_golang&quot;, because it the official and by far most popular library, and appears to have most features.</p><h2>Pros and Cons of the Options </h2><h3><a href="https://github.com/prometheus/client_golang">client_golang</a></h3><ul><li>Good, because it is the official library and has significant community support</li><li>Good, because it has all features we wanted and has advanced functionality, e.g,. sqlDBStats out-of-the-box, easily customizable...</li></ul><h3><a href="https://github.com/VictoriaMetrics/metrics">VictoriaMetrics</a></h3><ul><li>Good, because it depends on one exeternal package as compared to eight for client_golang</li><li>Bad, because it has far fewer users and maintainers than client_golang</li><li>Bad, because it is missing &quot;advanced funcationality&quot; from client_golang (their words)</li><li>Bad, because it doesn&#x27;t offer an implementation of collectors to register mulitple metrics at the same time</li></ul><h3><a href="https://github.com/poblish/promenade">promenade</a></h3><ul><li>Bad, because it has client_golang as a dependency</li><li>Bad, because it has only one author and one user</li><li>Bad, because it doesn&#x27;t offer an implementation of collectors to register mulitple metrics at the same time</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Deploy haproxy to route specific endpoints/methods to the new implementation]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - Traffic Splitter</link>
            <guid>ADR - Traffic Splitter</guid>
            <pubDate>Fri, 13 Aug 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: accepted]]></description>
            <content:encoded><![CDATA[<ul><li>Status: accepted</li><li>Deciders: <a href="https://github.com/andy-paine">Andy Paine</a>, <a href="https://github.com/svkrieger">Sven Krieger</a>, <a href="https://github.com/philippthun">Philipp Thun</a></li><li>Date: 2021-08-04</li></ul><h2>Context and Problem Statement</h2><p>The existing Cloud Controller is the reference implementation of the CF v3 API.
This project should avoid replacing the entire <code>cloud_controller_ng</code> project in a single &quot;big bang&quot; migration.
In order to build the new implementation iteratively, this project should be deployable in parallel with the existing implementation.
It should be possible to route individual API calls to the new Cloud Controller as soon as each endpoint is complete.</p><h2>Decision Drivers </h2><ul><li>Discover bugs early</li><li>Deliver value from reimplementation quickly</li><li>Minimise mean-time-to-recovery when bugs are discovered</li></ul><h2>Considered Options</h2><ol><li>Deploy new CC alongside existing CC in same instance group, using <code>nginx</code> for routing</li><li>Complete an entire endpoint at once (all HTTP methods) and use <code>gorouter</code> for path based routing</li><li>Deploy a dedicated path and HTTP method based router/proxy in front of old and new implementations and split traffic based on that</li></ol><h2>Decision Outcome</h2><p>Chosen option: 3 (deploy a path and HTTP method based router/proxy in front of old and new implementations and split traffic based on that),
because it is the only option that allows for separate scaling of old and new implementations as well as routing based on HTTP method and path.
Following images shows a rough routing example with just the verry specific <code>GET /v3/buildpacks/:guid</code> endpoint beeing routed to the go implementation. Everything else will be routed to the cloudcontroller_ng.
<img src="https://user-images.githubusercontent.com/5863788/145360535-a02ebd16-e339-461e-bff5-612b3c4c8f46.png" alt="image"/></p><h3>Positive Consequences </h3><ul><li>New implementation can be built in small units (endpoint + HTTP method)</li><li>Proxy can be registered only for certain routes, minimising throughput</li><li>Networking such as TLS in new implementation can be delayed until closer to completion (as proxy can perform this function)</li><li>Good support for HAProxy BOSH release as it is maintained by SAP team</li></ul><h3>Negative Consequences </h3><ul><li>Additional software to manage</li><li>HAProxy BOSH release is not that well suited to this use case</li></ul><h2>Pros and Cons of the Options </h2><h3>Option 1 (Deploy new CC alongside existing CC in same instance group, using <code>nginx</code> for routing)</h3><ul><li>Good, because does not change network architecture</li><li>Good, because does not add any new VMs</li><li>Bad, because cannot independently scale each implementation</li><li>Bad, because would require changes to the CAPI release to support this use case</li></ul><h3>Option 2 (Complete an entire endpoint at once (all HTTP methods) and use <code>gorouter</code> for path based routing)</h3><ul><li>Good, because does not change network architecture</li><li>Good, because can independently scale each implementation</li><li>Bad, because requires large amount of work to complete a whole endpoint</li><li>Bad, because requires new implementation to support TLS etc. for secure communication</li></ul><h2>Links </h2><ul><li><a href="https://github.com/cloudfoundry-incubator/haproxy-boshrelease">HAProxy BOSH release</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Use Zap logging as a performant and customizable structured logging framework]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - Logging Framework</link>
            <guid>ADR - Logging Framework</guid>
            <pubDate>Fri, 30 Jul 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: accepted]]></description>
            <content:encoded><![CDATA[<ul><li>Status: accepted</li><li>Deciders: <a href="https://github.com/FloThinksPi">Florian Braun</a></li><li>Date: 30.7.21</li></ul><h2>Context and Problem Statement</h2><p>We want our PoC to log various data in a structured way so that it is parsable by e.g. logsearch.</p><h2>Decision Drivers</h2><ul><li>Fast logging (no wasted cpu time)</li><li>Customizable to make it compatible with the way log parsing in cloudfoundry works and maybe be able to mirror the log schema of the Cloud_Controller_NG if wanted.</li><li>Community support, solutions should be a broadly adapted technology.</li></ul><h2>Considered Options</h2><ul><li><a href="https://github.com/sirupsen/logrus">logrus</a></li><li><a href="https://github.com/uber-go/zap">zap</a></li><li><a href="https://github.com/apex/log">apex</a></li><li><a href="https://github.com/rs/zerolog">zerolog</a></li></ul><h2>Decision Outcome</h2><p>Chosen option: &quot;&quot;, because it has bradly used, very fast and has all features we want.
As we started with zap, zerolog would be an alternative but we did not think it was worth it switching over as there was no obvious benefit.
So we sticked to use zap.</p><h2>Pros and Cons of the Options </h2><h3><a href="https://github.com/sirupsen/logrus">logrus</a></h3><ul><li>Good, because has all features we like</li><li>Bad, because dead project, recommends alternatives</li><li>Bad, because bad performance</li></ul><h3><a href="https://github.com/uber-go/zap">zap</a></h3><ul><li>Good, because very good performance,</li><li>Good, because broadly used</li><li>Good, because has all features we like</li></ul><h3><a href="https://github.com/apex/log">apex</a></h3><ul><li>Good, because has all features we like</li><li>Bad, because I dont like the interface</li><li>Bad, because it is not used by as much people as zap</li><li>Bad, because it is as slow as logrus</li></ul><h3><a href="https://github.com/rs/zerolog">zerolog</a></h3><ul><li>Good, because its also very fast.</li><li>Good, because has all features we like</li><li>Good, because also broadly used but a bit less than zap</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Use sqlboiler together with build tags to support multiple databases]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - SQL Framework</link>
            <guid>ADR - SQL Framework</guid>
            <pubDate>Wed, 28 Jul 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: accepted]]></description>
            <content:encoded><![CDATA[<ul><li>Status: accepted</li><li>Deciders: <a href="https://github.com/FloThinksPi">Florian Braun</a>, <a href="https://github.com/andy-paine">Andy Paine</a>, <a href="https://github.com/mmisoch">Marc Misoch</a></li><li>Date: 2021-07-28</li></ul><h2>Context and Problem Statement</h2><p>The existing Cloud Controller supports both Postgres and MySQL as a storage backend and both options are used in real production deployments today.
In order to replace the existing Cloud Controller implementation, this project should also be able to support both</p><h2>Decision Drivers</h2><ul><li>Community support: should be able to work with any CC DB</li><li>Performance: want a minimal runtime overhead</li><li>Performance: want control over SQL queries used to be able to optimise</li></ul><h2>Considered Options</h2><ol><li><a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> with separate packages for Postgres and MySQL</li><li><a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> with an extracted interface that is implemented by both Postgres and MySQL</li><li><a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> in a shared package with different build tags for each implementation</li><li><a href="https://gorm.io/index.html">GORM</a></li><li><a href="https://github.com/xo/xo">xo/xo</a></li></ol><h2>Decision Outcome</h2><p>Chosen option: 3 (<a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> in a shared package with different build tags for each implementation) because this allows all of the model code to be generated from an existing schema and lets the compiler type check that the generated implementations have the same signatures without needing to manipulate the generated code much.</p><h3>Positive Consequences</h3><ul><li>Model code can be regularly regenerated when CC DB schema changes (due to new migrations in existing implementation)</li><li>Smaller binaries as each only contains code relevant to that DB backend</li><li>Compile time checks that the generated code has the same function signatures for both implementations (or at least for all functions that are actually used)</li><li>Generated code can be easily extended to support optimisations</li></ul><h3>Negative Consequences</h3><ul><li>Extra tooling is required to rename and combine the files into a single package and add build tags</li><li>Directory containing generated files is extremely large</li><li>Developers need to supply build tags in order to browse, lint, compile and test code</li></ul><h2>Pros and Cons of other options</h2><h3>Option 1 (<a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> with separate packages for Postgres and MySQL)</h3><ul><li>Good, because <code>sqlboiler</code> can be run to generate the code without modification</li><li>Bad, because all controller code would need to do an <code>if</code>/<code>switch</code> statement on database type</li><li>Bad, because binaries will contain redundant code for other databases</li></ul><h3>Option 2 (<a href="https://github.com/volatiletech/sqlboiler">sqlboiler</a> with an extracted interface that is implemented by both Postgres and MySQL)</h3><ul><li>Good, because the interface could abstract between the two database</li><li>Good, because compiler would check that both generated implementations satisfy interface</li><li>Bad, because requires significant effort to extract complex <code>sqlboiler</code> interfaces</li><li>Bad, because some functions are static and cannot be extracted into an interface</li></ul><h3>Option 4 <a href="https://gorm.io/index.html">GORM</a></h3><ul><li>Good, because good documentation</li><li>Good, because controller code that interacts with database models is easy to write</li><li>Bad, because little/no support for generating models from existing schema</li><li>Bad, because has runtime overhead of using reflection</li></ul><h3>Option 5 <a href="https://github.com/xo/xo">xo/xo</a></h3><ul><li>Good, because generated models are extremely simple</li><li>Good, because templates are easy to customise</li><li>Bad, because generated models have no support for eager loading</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Use Markdown Architectural Decision Records]]></title>
            <link>https://pages.github.com/go-cf-api/adrs/ADR - ADR Format</link>
            <guid>ADR - ADR Format</guid>
            <pubDate>Sun, 25 Jul 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[* Status: accepted]]></description>
            <content:encoded><![CDATA[<ul><li>Status: accepted</li><li>Deciders: <a href="https://github.com/andy-paine">Andy Paine</a></li><li>Date: 2021-07-28</li></ul><h2>Context and Problem Statement</h2><p>We want to record architectural decisions made in this project.
Which format and structure should these records follow?</p><h2>Considered Options</h2><ul><li><a href="https://adr.github.io/madr/">MADR</a> 2.1.2 – The Markdown Architectural Decision Records</li><li><a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions">Michael Nygard&#x27;s template</a> – The first incarnation of the term &quot;ADR&quot;</li><li><a href="https://www.infoq.com/articles/sustainable-architectural-design-decisions">Sustainable Architectural Decisions</a> – The Y-Statements</li><li>Other templates listed at <a href="https://github.com/joelparkerhenderson/architecture_decision_record">https://github.com/joelparkerhenderson/architecture_decision_record</a></li><li>Formless – No conventions for file format and structure</li></ul><h2>Decision Outcome</h2><p>Chosen option: &quot;MADR 2.1.2&quot;, because</p><ul><li>Implicit assumptions should be made explicit.
Design documentation is important to enable people understanding the decisions later on.
See also <a href="https://doi.org/10.1109/TSE.1986.6312940">A rational design process: How and why to fake it</a>.</li><li>The MADR format is lean and fits our development style.</li><li>The MADR structure is comprehensible and facilitates usage &amp; maintenance.</li><li>The MADR project is vivid.</li><li>Version 2.1.2 is the latest one available when starting to document ADRs.</li></ul>]]></content:encoded>
        </item>
    </channel>
</rss>