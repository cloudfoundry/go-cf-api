"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8841],{3905:function(e,a,t){t.d(a,{Zo:function(){return u},kt:function(){return d}});var l=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function n(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);a&&(l=l.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,l)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?n(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,l,r=function(e,a){if(null==e)return{};var t,l,r={},n=Object.keys(e);for(l=0;l<n.length;l++)t=n[l],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(l=0;l<n.length;l++)t=n[l],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=l.createContext({}),o=function(e){var a=l.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=o(e.components);return l.createElement(c.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return l.createElement(l.Fragment,{},a)}},m=l.forwardRef((function(e,a){var t=e.components,r=e.mdxType,n=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=o(t),d=r,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||n;return t?l.createElement(f,i(i({ref:a},u),{},{components:t})):l.createElement(f,i({ref:a},u))}));function d(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var n=t.length,i=new Array(n);i[0]=m;var s={};for(var c in a)hasOwnProperty.call(a,c)&&(s[c]=a[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var o=2;o<n;o++)i[o]=t[o];return l.createElement.apply(null,i)}return l.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2618:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return o},toc:function(){return u},default:function(){return m}});var l=t(7462),r=t(3366),n=(t(7294),t(3905)),i=["components"],s={},c=void 0,o={unversionedId:"Packages/internal/apicommon/v3/metadata",id:"Packages/internal/apicommon/v3/metadata",isDocsHomePage:!1,title:"metadata",description:"`go",source:"@site/godocs/Packages/internal/apicommon/v3/metadata.md",sourceDirName:"Packages/internal/apicommon/v3",slug:"/Packages/internal/apicommon/v3/metadata",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/metadata",editUrl:"https://github.com/cloudfoundry/go-cf-api/edit/main/docs/godocs/Packages/internal/apicommon/v3/metadata.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"auth",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/auth"},next:{title:"mocks",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/metadata/mocks"}},u=[{value:"Index",id:"index",children:[]},{value:"Variables",id:"variables",children:[]},{value:"func andIn",id:"func-andin",children:[]},{value:"func subqueryBase",id:"func-subquerybase",children:[]},{value:"func whereIn",id:"func-wherein",children:[]},{value:"type Key",id:"type-key",children:[{value:"func (Key) isValid",id:"func-key-isvalid",children:[]}]},{value:"type LabelSelector",id:"type-labelselector",children:[]},{value:"type LabelSelectorFilters",id:"type-labelselectorfilters",children:[]},{value:"type LabelSelectorParser",id:"type-labelselectorparser",children:[{value:"func NewLabelSelectorParser",id:"func-newlabelselectorparser",children:[]}]},{value:"type LabelSelectorSlice",id:"type-labelselectorslice",children:[{value:"func (LabelSelectorSlice) Filters",id:"func-labelselectorslice-filters",children:[]},{value:"func (*LabelSelectorSlice) append",id:"func-labelselectorslice-append",children:[]}]},{value:"type Map",id:"type-map",children:[{value:"func getKeyValue",id:"func-getkeyvalue",children:[]}]},{value:"type Metadata",id:"type-metadata",children:[{value:"func Get",id:"func-get",children:[]}]},{value:"type Operator",id:"type-operator",children:[{value:"func (Operator) isValid",id:"func-operator-isvalid",children:[]}]},{value:"type exists",id:"type-exists",children:[{value:"func (exists) Filter",id:"func-exists-filter",children:[]}]},{value:"type inEquals",id:"type-inequals",children:[{value:"func (inEquals) Filter",id:"func-inequals-filter",children:[]},{value:"func (inEquals) any",id:"func-inequals-any",children:[]}]},{value:"type labelSelectorParser",id:"type-labelselectorparser-1",children:[{value:"func (*labelSelectorParser) Parse",id:"func-labelselectorparser-parse",children:[]}]},{value:"type notExists",id:"type-notexists",children:[{value:"func (notExists) Filter",id:"func-notexists-filter",children:[]}]},{value:"type notInEquals",id:"type-notinequals",children:[{value:"func (notInEquals) Filter",id:"func-notinequals-filter",children:[]},{value:"func (notInEquals) any",id:"func-notinequals-any",children:[]}]}],p={toc:u};function m(e){var a=e.components,t=(0,r.Z)(e,i);return(0,n.kt)("wrapper",(0,l.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"metadata"},"metadata"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'import "github.com/cloudfoundry/go-cf-api/internal/apicommon/v3/metadata"\n')),(0,n.kt)("h2",{id:"index"},"Index"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#variables"},"Variables")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-andin"},"func andIn(field string, slice []string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-subquerybase"},"func subqueryBase(resourceTable, labelsTable string) []qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-wherein"},"func whereIn(field string, slice []Key) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-key"},"type Key"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-key-isvalid"},"func (k Key) isValid() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselector"},"type LabelSelector")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorfilters"},"type LabelSelectorFilters")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorparser"},"type LabelSelectorParser"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-newlabelselectorparser"},"func NewLabelSelectorParser() LabelSelectorParser")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorslice"},"type LabelSelectorSlice"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorslice-filters"},"func (selectors LabelSelectorSlice) Filters(resourceTable, labelsTable string) []qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorslice-append"},"func (selectors *LabelSelectorSlice) append(key Key, operator Operator, values []string) error")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-map"},"type Map"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-getkeyvalue"},"func getKeyValue(slice interface{}, keyField, valueField string) (keyValueMap Map, err error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-metadata"},"type Metadata"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-get"},"func Get(annotationsSlice, labelsSlice interface{}) (Metadata, error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-operator"},"type Operator"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-operator-isvalid"},"func (op Operator) isValid() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-exists"},"type exists"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-exists-filter"},"func (s exists) Filter(resourceTable, labelsTable string) qm.QueryMod")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-inequals"},"type inEquals"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-inequals-filter"},"func (s inEquals) Filter(resourceTable, labelsTable string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-inequals-any"},"func (s inEquals) any() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorparser"},"type labelSelectorParser"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorparser-parse"},"func (l *labelSelectorParser) Parse(labelSelector string) (LabelSelectorFilters, error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-notexists"},"type notExists"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notexists-filter"},"func (s notExists) Filter(resourceTable, labelsTable string) qm.QueryMod")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-notinequals"},"type notInEquals"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notinequals-filter"},"func (s notInEquals) Filter(resourceTable, labelsTable string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notinequals-any"},"func (s notInEquals) any() bool"))))),(0,n.kt)("h2",{id:"variables"},"Variables"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    // All label tables should be the same so just pick a resource to get the column names from\n    guidColumn         = models.Quote(models.AppColumns.GUID)\n    resourceGUIDColumn = models.Quote(models.AppLabelColumns.ResourceGUID)\n    keyColumn          = models.Quote(models.AppLabelColumns.KeyName)\n    valueColumn        = models.Quote(models.AppLabelColumns.Value)\n)\n")),(0,n.kt)("h2",{id:"func-andin"},"func andIn"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func andIn(field string, slice []string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"func-subquerybase"},"func subqueryBase"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func subqueryBase(resourceTable, labelsTable string) []qm.QueryMod\n")),(0,n.kt)("h2",{id:"func-wherein"},"func whereIn"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func whereIn(field string, slice []Key) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-key"},"type Key"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Key string\n")),(0,n.kt)("h3",{id:"func-key-isvalid"},"func ","(","Key",")"," isValid"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (k Key) isValid() bool\n")),(0,n.kt)("h2",{id:"type-labelselector"},"type LabelSelector"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelector struct {\n    Key      Key\n    Operator Operator\n    Values   []string\n}\n")),(0,n.kt)("h2",{id:"type-labelselectorfilters"},"type LabelSelectorFilters"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorFilters interface {\n    Filters(resourceTable, labelsTable string) []qm.QueryMod\n}\n")),(0,n.kt)("h2",{id:"type-labelselectorparser"},"type LabelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorParser interface {\n    Parse(labelSelector string) (LabelSelectorFilters, error)\n}\n")),(0,n.kt)("h3",{id:"func-newlabelselectorparser"},"func NewLabelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func NewLabelSelectorParser() LabelSelectorParser\n")),(0,n.kt)("h2",{id:"type-labelselectorslice"},"type LabelSelectorSlice"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorSlice []LabelSelector\n")),(0,n.kt)("h3",{id:"func-labelselectorslice-filters"},"func ","(","LabelSelectorSlice",")"," Filters"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (selectors LabelSelectorSlice) Filters(resourceTable, labelsTable string) []qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-labelselectorslice-append"},"func ","(","*","LabelSelectorSlice",")"," append"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (selectors *LabelSelectorSlice) append(key Key, operator Operator, values []string) error\n")),(0,n.kt)("h2",{id:"type-map"},"type Map"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Map map[string]null.String\n")),(0,n.kt)("h3",{id:"func-getkeyvalue"},"func getKeyValue"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func getKeyValue(slice interface{}, keyField, valueField string) (keyValueMap Map, err error)\n")),(0,n.kt)("h2",{id:"type-metadata"},"type Metadata"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'type Metadata struct {\n    Labels      Map `json:"labels"`\n    Annotations Map `json:"annotations"`\n}\n')),(0,n.kt)("h3",{id:"func-get"},"func Get"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func Get(annotationsSlice, labelsSlice interface{}) (Metadata, error)\n")),(0,n.kt)("h2",{id:"type-operator"},"type Operator"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Operator string\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'const (\n    Exists    Operator = ""\n    NotExists Operator = "!"\n    Eq        Operator = "="\n    EqAlt     Operator = "=="\n    NotEq     Operator = "!="\n    In        Operator = "in"\n    NotIn     Operator = "notin"\n\n    AllowedChars          = "[[:alnum:]][[:alnum:]._-]*"  // allow chars in keys: a-z,A-z,0-9,-,_,.\n    AllowedCharsWithComma = "[[:alnum:]][[:alnum:]._,-]*" // in clauses can contain commas\n\n)\n')),(0,n.kt)("h3",{id:"func-operator-isvalid"},"func ","(","Operator",")"," isValid"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (op Operator) isValid() bool\n")),(0,n.kt)("h2",{id:"type-exists"},"type exists"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type exists []Key\n")),(0,n.kt)("h3",{id:"func-exists-filter"},"func ","(","exists",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s exists) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-inequals"},"type inEquals"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type inEquals struct {\n    in  []LabelSelector\n    eq  []LabelSelector\n}\n")),(0,n.kt)("h3",{id:"func-inequals-filter"},"func ","(","inEquals",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s inEquals) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-inequals-any"},"func ","(","inEquals",")"," any"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s inEquals) any() bool\n")),(0,n.kt)("h2",{id:"type-labelselectorparser-1"},"type labelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type labelSelectorParser struct{}\n")),(0,n.kt)("h3",{id:"func-labelselectorparser-parse"},"func ","(","*","labelSelectorParser",")"," Parse"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (l *labelSelectorParser) Parse(labelSelector string) (LabelSelectorFilters, error)\n")),(0,n.kt)("h2",{id:"type-notexists"},"type notExists"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type notExists []Key\n")),(0,n.kt)("h3",{id:"func-notexists-filter"},"func ","(","notExists",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notExists) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-notinequals"},"type notInEquals"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type notInEquals struct {\n    notIn []LabelSelector\n    notEq []LabelSelector\n}\n")),(0,n.kt)("h3",{id:"func-notinequals-filter"},"func ","(","notInEquals",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notInEquals) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-notinequals-any"},"func ","(","notInEquals",")"," any"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notInEquals) any() bool\n")),(0,n.kt)("p",null,"Generated by ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/princjef/gomarkdoc"},"gomarkdoc")))}m.isMDXComponent=!0}}]);