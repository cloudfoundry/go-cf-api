"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8841],{3905:function(e,a,l){l.d(a,{Zo:function(){return o},kt:function(){return d}});var t=l(7294);function r(e,a,l){return a in e?Object.defineProperty(e,a,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[a]=l,e}function n(e,a){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),l.push.apply(l,t)}return l}function i(e){for(var a=1;a<arguments.length;a++){var l=null!=arguments[a]?arguments[a]:{};a%2?n(Object(l),!0).forEach((function(a){r(e,a,l[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):n(Object(l)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(l,a))}))}return e}function s(e,a){if(null==e)return{};var l,t,r=function(e,a){if(null==e)return{};var l,t,r={},n=Object.keys(e);for(t=0;t<n.length;t++)l=n[t],a.indexOf(l)>=0||(r[l]=e[l]);return r}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)l=n[t],a.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(r[l]=e[l])}return r}var c=t.createContext({}),u=function(e){var a=t.useContext(c),l=a;return e&&(l="function"==typeof e?e(a):i(i({},a),e)),l},o=function(e){var a=u(e.components);return t.createElement(c.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var l=e.components,r=e.mdxType,n=e.originalType,c=e.parentName,o=s(e,["components","mdxType","originalType","parentName"]),m=u(l),d=r,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||n;return l?t.createElement(f,i(i({ref:a},o),{},{components:l})):t.createElement(f,i({ref:a},o))}));function d(e,a){var l=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var n=l.length,i=new Array(n);i[0]=m;var s={};for(var c in a)hasOwnProperty.call(a,c)&&(s[c]=a[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<n;u++)i[u]=l[u];return t.createElement.apply(null,i)}return t.createElement.apply(null,l)}m.displayName="MDXCreateElement"},2618:function(e,a,l){l.r(a),l.d(a,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return o},default:function(){return m}});var t=l(7462),r=l(3366),n=(l(7294),l(3905)),i=["components"],s={},c=void 0,u={unversionedId:"Packages/internal/apicommon/v3/metadata",id:"Packages/internal/apicommon/v3/metadata",title:"metadata",description:"Index",source:"@site/godocs/Packages/internal/apicommon/v3/metadata.md",sourceDirName:"Packages/internal/apicommon/v3",slug:"/Packages/internal/apicommon/v3/metadata",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/metadata",editUrl:"https://github.com/cloudfoundry/go-cf-api/edit/main/docs/godocs/Packages/internal/apicommon/v3/metadata.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"auth",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/auth"},next:{title:"pagination",permalink:"/go-cf-api/godocs/Packages/internal/apicommon/v3/pagination"}},o=[{value:"Index",id:"index",children:[],level:2},{value:"Variables",id:"variables",children:[],level:2},{value:"func andIn",id:"func-andin",children:[],level:2},{value:"func subqueryBase",id:"func-subquerybase",children:[],level:2},{value:"func whereIn",id:"func-wherein",children:[],level:2},{value:"type Key",id:"type-key",children:[{value:"func (Key) isValid",id:"func-key-isvalid",children:[],level:3}],level:2},{value:"type LabelSelector",id:"type-labelselector",children:[],level:2},{value:"type LabelSelectorFilters",id:"type-labelselectorfilters",children:[],level:2},{value:"type LabelSelectorParser",id:"type-labelselectorparser",children:[{value:"func NewLabelSelectorParser",id:"func-newlabelselectorparser",children:[],level:3}],level:2},{value:"type LabelSelectorSlice",id:"type-labelselectorslice",children:[{value:"func (LabelSelectorSlice) Filters",id:"func-labelselectorslice-filters",children:[],level:3},{value:"func (*LabelSelectorSlice) append",id:"func-labelselectorslice-append",children:[],level:3}],level:2},{value:"type Map",id:"type-map",children:[{value:"func getKeyValue",id:"func-getkeyvalue",children:[],level:3}],level:2},{value:"type Metadata",id:"type-metadata",children:[{value:"func Get",id:"func-get",children:[],level:3}],level:2},{value:"type Operator",id:"type-operator",children:[{value:"func (Operator) isValid",id:"func-operator-isvalid",children:[],level:3}],level:2},{value:"type exists",id:"type-exists",children:[{value:"func (exists) Filter",id:"func-exists-filter",children:[],level:3}],level:2},{value:"type inEquals",id:"type-inequals",children:[{value:"func (inEquals) Filter",id:"func-inequals-filter",children:[],level:3},{value:"func (inEquals) any",id:"func-inequals-any",children:[],level:3}],level:2},{value:"type labelSelectorParser",id:"type-labelselectorparser-1",children:[{value:"func (*labelSelectorParser) Parse",id:"func-labelselectorparser-parse",children:[],level:3}],level:2},{value:"type notExists",id:"type-notexists",children:[{value:"func (notExists) Filter",id:"func-notexists-filter",children:[],level:3}],level:2},{value:"type notInEquals",id:"type-notinequals",children:[{value:"func (notInEquals) Filter",id:"func-notinequals-filter",children:[],level:3},{value:"func (notInEquals) any",id:"func-notinequals-any",children:[],level:3}],level:2}],p={toc:o};function m(e){var a=e.components,l=(0,r.Z)(e,i);return(0,n.kt)("wrapper",(0,t.Z)({},p,l,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"metadata"},"metadata"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'import "github.com/cloudfoundry/go-cf-api/internal/apicommon/v3/metadata"\n')),(0,n.kt)("h2",{id:"index"},"Index"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#variables"},"Variables")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-andin"},"func andIn(field string, slice []string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-subquerybase"},"func subqueryBase(resourceTable, labelsTable string) []qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-wherein"},"func whereIn(field string, slice []Key) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-key"},"type Key"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-key-isvalid"},"func (k Key) isValid() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselector"},"type LabelSelector")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorfilters"},"type LabelSelectorFilters")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorparser"},"type LabelSelectorParser"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-newlabelselectorparser"},"func NewLabelSelectorParser() LabelSelectorParser")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorslice"},"type LabelSelectorSlice"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorslice-filters"},"func (selectors LabelSelectorSlice) Filters(resourceTable, labelsTable string) []qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorslice-append"},"func (selectors *LabelSelectorSlice) append(key Key, operator Operator, values []string) error")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-map"},"type Map"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-getkeyvalue"},"func getKeyValue(slice interface{}, keyField, valueField string) (keyValueMap Map, err error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-metadata"},"type Metadata"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-get"},"func Get(annotationsSlice, labelsSlice interface{}) (Metadata, error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-operator"},"type Operator"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-operator-isvalid"},"func (op Operator) isValid() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-exists"},"type exists"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-exists-filter"},"func (s exists) Filter(resourceTable, labelsTable string) qm.QueryMod")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-inequals"},"type inEquals"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-inequals-filter"},"func (s inEquals) Filter(resourceTable, labelsTable string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-inequals-any"},"func (s inEquals) any() bool")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-labelselectorparser"},"type labelSelectorParser"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-labelselectorparser-parse"},"func (l *labelSelectorParser) Parse(labelSelector string) (LabelSelectorFilters, error)")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-notexists"},"type notExists"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notexists-filter"},"func (s notExists) Filter(resourceTable, labelsTable string) qm.QueryMod")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#type-notinequals"},"type notInEquals"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notinequals-filter"},"func (s notInEquals) Filter(resourceTable, labelsTable string) qm.QueryMod")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#func-notinequals-any"},"func (s notInEquals) any() bool"))))),(0,n.kt)("h2",{id:"variables"},"Variables"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    // All label tables should be the same so just pick a resource to get the column names from\n    guidColumn         = models.Quote(models.AppColumns.GUID)\n    resourceGUIDColumn = models.Quote(models.AppLabelColumns.ResourceGUID)\n    keyColumn          = models.Quote(models.AppLabelColumns.KeyName)\n    valueColumn        = models.Quote(models.AppLabelColumns.Value)\n)\n")),(0,n.kt)("h2",{id:"func-andin"},"func andIn"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func andIn(field string, slice []string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"func-subquerybase"},"func subqueryBase"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func subqueryBase(resourceTable, labelsTable string) []qm.QueryMod\n")),(0,n.kt)("h2",{id:"func-wherein"},"func whereIn"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func whereIn(field string, slice []Key) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-key"},"type Key"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Key string\n")),(0,n.kt)("h3",{id:"func-key-isvalid"},"func ","(","Key",")"," isValid"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (k Key) isValid() bool\n")),(0,n.kt)("h2",{id:"type-labelselector"},"type LabelSelector"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelector struct {\n    Key      Key\n    Operator Operator\n    Values   []string\n}\n")),(0,n.kt)("h2",{id:"type-labelselectorfilters"},"type LabelSelectorFilters"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorFilters interface {\n    Filters(resourceTable, labelsTable string) []qm.QueryMod\n}\n")),(0,n.kt)("h2",{id:"type-labelselectorparser"},"type LabelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorParser interface {\n    Parse(labelSelector string) (LabelSelectorFilters, error)\n}\n")),(0,n.kt)("h3",{id:"func-newlabelselectorparser"},"func NewLabelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func NewLabelSelectorParser() LabelSelectorParser\n")),(0,n.kt)("h2",{id:"type-labelselectorslice"},"type LabelSelectorSlice"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type LabelSelectorSlice []LabelSelector\n")),(0,n.kt)("h3",{id:"func-labelselectorslice-filters"},"func ","(","LabelSelectorSlice",")"," Filters"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (selectors LabelSelectorSlice) Filters(resourceTable, labelsTable string) []qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-labelselectorslice-append"},"func ","(","*","LabelSelectorSlice",")"," append"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (selectors *LabelSelectorSlice) append(key Key, operator Operator, values []string) error\n")),(0,n.kt)("h2",{id:"type-map"},"type Map"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Map map[string]null.String\n")),(0,n.kt)("h3",{id:"func-getkeyvalue"},"func getKeyValue"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func getKeyValue(slice interface{}, keyField, valueField string) (keyValueMap Map, err error)\n")),(0,n.kt)("h2",{id:"type-metadata"},"type Metadata"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'type Metadata struct {\n    Labels      Map `json:"labels"`\n    Annotations Map `json:"annotations"`\n}\n')),(0,n.kt)("h3",{id:"func-get"},"func Get"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func Get(annotationsSlice, labelsSlice interface{}) (Metadata, error)\n")),(0,n.kt)("h2",{id:"type-operator"},"type Operator"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type Operator string\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'const (\n    Exists    Operator = ""\n    NotExists Operator = "!"\n    Eq        Operator = "="\n    EqAlt     Operator = "=="\n    NotEq     Operator = "!="\n    In        Operator = "in"\n    NotIn     Operator = "notin"\n\n    AllowedChars          = "[[:alnum:]][[:alnum:]._-]*"  // allow chars in keys: a-z,A-z,0-9,-,_,.\n    AllowedCharsWithComma = "[[:alnum:]][[:alnum:]._,-]*" // in clauses can contain commas\n\n)\n')),(0,n.kt)("h3",{id:"func-operator-isvalid"},"func ","(","Operator",")"," isValid"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (op Operator) isValid() bool\n")),(0,n.kt)("h2",{id:"type-exists"},"type exists"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type exists []Key\n")),(0,n.kt)("h3",{id:"func-exists-filter"},"func ","(","exists",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s exists) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-inequals"},"type inEquals"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type inEquals struct {\n    in  []LabelSelector\n    eq  []LabelSelector\n}\n")),(0,n.kt)("h3",{id:"func-inequals-filter"},"func ","(","inEquals",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s inEquals) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-inequals-any"},"func ","(","inEquals",")"," any"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s inEquals) any() bool\n")),(0,n.kt)("h2",{id:"type-labelselectorparser-1"},"type labelSelectorParser"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type labelSelectorParser struct{}\n")),(0,n.kt)("h3",{id:"func-labelselectorparser-parse"},"func ","(","*","labelSelectorParser",")"," Parse"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (l *labelSelectorParser) Parse(labelSelector string) (LabelSelectorFilters, error)\n")),(0,n.kt)("h2",{id:"type-notexists"},"type notExists"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type notExists []Key\n")),(0,n.kt)("h3",{id:"func-notexists-filter"},"func ","(","notExists",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notExists) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h2",{id:"type-notinequals"},"type notInEquals"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"type notInEquals struct {\n    notIn []LabelSelector\n    notEq []LabelSelector\n}\n")),(0,n.kt)("h3",{id:"func-notinequals-filter"},"func ","(","notInEquals",")"," Filter"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notInEquals) Filter(resourceTable, labelsTable string) qm.QueryMod\n")),(0,n.kt)("h3",{id:"func-notinequals-any"},"func ","(","notInEquals",")"," any"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"func (s notInEquals) any() bool\n")),(0,n.kt)("p",null,"Generated by ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/princjef/gomarkdoc"},"gomarkdoc")))}m.isMDXComponent=!0}}]);