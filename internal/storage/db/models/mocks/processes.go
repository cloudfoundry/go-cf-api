//go:build unit
// +build unit

//

// Code generated by MockGen. DO NOT EDIT.
// Source: psql_processes.go

// Package mock_models is a generated GoMock package.
package mock_models

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	boil "github.com/volatiletech/sqlboiler/v4/boil"
	models "github.tools.sap/cloudfoundry/cloudgontroller/internal/storage/db/models"
)

// MockProcessUpserter is a mock of ProcessUpserter interface.
type MockProcessUpserter struct {
	ctrl     *gomock.Controller
	recorder *MockProcessUpserterMockRecorder
}

// MockProcessUpserterMockRecorder is the mock recorder for MockProcessUpserter.
type MockProcessUpserterMockRecorder struct {
	mock *MockProcessUpserter
}

// NewMockProcessUpserter creates a new mock instance.
func NewMockProcessUpserter(ctrl *gomock.Controller) *MockProcessUpserter {
	mock := &MockProcessUpserter{ctrl: ctrl}
	mock.recorder = &MockProcessUpserterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessUpserter) EXPECT() *MockProcessUpserterMockRecorder {
	return m.recorder
}

// Upsert mocks base method.
func (m *MockProcessUpserter) Upsert(o *models.Process, ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", o, ctx, exec, updateColumns, insertColumns)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockProcessUpserterMockRecorder) Upsert(o, ctx, exec, updateColumns, insertColumns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockProcessUpserter)(nil).Upsert), o, ctx, exec, updateColumns, insertColumns)
}

// MockProcessFinisher is a mock of ProcessFinisher interface.
type MockProcessFinisher struct {
	ctrl     *gomock.Controller
	recorder *MockProcessFinisherMockRecorder
}

// MockProcessFinisherMockRecorder is the mock recorder for MockProcessFinisher.
type MockProcessFinisherMockRecorder struct {
	mock *MockProcessFinisher
}

// NewMockProcessFinisher creates a new mock instance.
func NewMockProcessFinisher(ctrl *gomock.Controller) *MockProcessFinisher {
	mock := &MockProcessFinisher{ctrl: ctrl}
	mock.recorder = &MockProcessFinisherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessFinisher) EXPECT() *MockProcessFinisherMockRecorder {
	return m.recorder
}

// All mocks base method.
func (m *MockProcessFinisher) All(ctx context.Context, exec boil.ContextExecutor) (models.ProcessSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "All", ctx, exec)
	ret0, _ := ret[0].(models.ProcessSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// All indicates an expected call of All.
func (mr *MockProcessFinisherMockRecorder) All(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockProcessFinisher)(nil).All), ctx, exec)
}

// Count mocks base method.
func (m *MockProcessFinisher) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockProcessFinisherMockRecorder) Count(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockProcessFinisher)(nil).Count), ctx, exec)
}

// Exists mocks base method.
func (m *MockProcessFinisher) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", ctx, exec)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockProcessFinisherMockRecorder) Exists(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockProcessFinisher)(nil).Exists), ctx, exec)
}

// One mocks base method.
func (m *MockProcessFinisher) One(ctx context.Context, exec boil.ContextExecutor) (*models.Process, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "One", ctx, exec)
	ret0, _ := ret[0].(*models.Process)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// One indicates an expected call of One.
func (mr *MockProcessFinisherMockRecorder) One(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "One", reflect.TypeOf((*MockProcessFinisher)(nil).One), ctx, exec)
}

// MockProcessFinder is a mock of ProcessFinder interface.
type MockProcessFinder struct {
	ctrl     *gomock.Controller
	recorder *MockProcessFinderMockRecorder
}

// MockProcessFinderMockRecorder is the mock recorder for MockProcessFinder.
type MockProcessFinderMockRecorder struct {
	mock *MockProcessFinder
}

// NewMockProcessFinder creates a new mock instance.
func NewMockProcessFinder(ctrl *gomock.Controller) *MockProcessFinder {
	mock := &MockProcessFinder{ctrl: ctrl}
	mock.recorder = &MockProcessFinderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessFinder) EXPECT() *MockProcessFinderMockRecorder {
	return m.recorder
}

// FindProcess mocks base method.
func (m *MockProcessFinder) FindProcess(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*models.Process, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, exec, iD}
	for _, a := range selectCols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindProcess", varargs...)
	ret0, _ := ret[0].(*models.Process)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindProcess indicates an expected call of FindProcess.
func (mr *MockProcessFinderMockRecorder) FindProcess(ctx, exec, iD interface{}, selectCols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, exec, iD}, selectCols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindProcess", reflect.TypeOf((*MockProcessFinder)(nil).FindProcess), varargs...)
}

// MockProcessInserter is a mock of ProcessInserter interface.
type MockProcessInserter struct {
	ctrl     *gomock.Controller
	recorder *MockProcessInserterMockRecorder
}

// MockProcessInserterMockRecorder is the mock recorder for MockProcessInserter.
type MockProcessInserterMockRecorder struct {
	mock *MockProcessInserter
}

// NewMockProcessInserter creates a new mock instance.
func NewMockProcessInserter(ctrl *gomock.Controller) *MockProcessInserter {
	mock := &MockProcessInserter{ctrl: ctrl}
	mock.recorder = &MockProcessInserterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessInserter) EXPECT() *MockProcessInserterMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockProcessInserter) Insert(o *models.Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", o, ctx, exec, columns)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockProcessInserterMockRecorder) Insert(o, ctx, exec, columns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockProcessInserter)(nil).Insert), o, ctx, exec, columns)
}

// MockProcessUpdater is a mock of ProcessUpdater interface.
type MockProcessUpdater struct {
	ctrl     *gomock.Controller
	recorder *MockProcessUpdaterMockRecorder
}

// MockProcessUpdaterMockRecorder is the mock recorder for MockProcessUpdater.
type MockProcessUpdaterMockRecorder struct {
	mock *MockProcessUpdater
}

// NewMockProcessUpdater creates a new mock instance.
func NewMockProcessUpdater(ctrl *gomock.Controller) *MockProcessUpdater {
	mock := &MockProcessUpdater{ctrl: ctrl}
	mock.recorder = &MockProcessUpdaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessUpdater) EXPECT() *MockProcessUpdaterMockRecorder {
	return m.recorder
}

// Update mocks base method.
func (m *MockProcessUpdater) Update(o *models.Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", o, ctx, exec, columns)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockProcessUpdaterMockRecorder) Update(o, ctx, exec, columns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockProcessUpdater)(nil).Update), o, ctx, exec, columns)
}

// UpdateAll mocks base method.
func (m *MockProcessUpdater) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols models.M) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAll", ctx, exec, cols)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAll indicates an expected call of UpdateAll.
func (mr *MockProcessUpdaterMockRecorder) UpdateAll(ctx, exec, cols interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAll", reflect.TypeOf((*MockProcessUpdater)(nil).UpdateAll), ctx, exec, cols)
}

// UpdateAllSlice mocks base method.
func (m *MockProcessUpdater) UpdateAllSlice(o models.ProcessSlice, ctx context.Context, exec boil.ContextExecutor, cols models.M) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAllSlice", o, ctx, exec, cols)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAllSlice indicates an expected call of UpdateAllSlice.
func (mr *MockProcessUpdaterMockRecorder) UpdateAllSlice(o, ctx, exec, cols interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAllSlice", reflect.TypeOf((*MockProcessUpdater)(nil).UpdateAllSlice), o, ctx, exec, cols)
}

// MockProcessDeleter is a mock of ProcessDeleter interface.
type MockProcessDeleter struct {
	ctrl     *gomock.Controller
	recorder *MockProcessDeleterMockRecorder
}

// MockProcessDeleterMockRecorder is the mock recorder for MockProcessDeleter.
type MockProcessDeleterMockRecorder struct {
	mock *MockProcessDeleter
}

// NewMockProcessDeleter creates a new mock instance.
func NewMockProcessDeleter(ctrl *gomock.Controller) *MockProcessDeleter {
	mock := &MockProcessDeleter{ctrl: ctrl}
	mock.recorder = &MockProcessDeleterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessDeleter) EXPECT() *MockProcessDeleterMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockProcessDeleter) Delete(o *models.Process, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", o, ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockProcessDeleterMockRecorder) Delete(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockProcessDeleter)(nil).Delete), o, ctx, exec)
}

// DeleteAll mocks base method.
func (m *MockProcessDeleter) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAll", ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAll indicates an expected call of DeleteAll.
func (mr *MockProcessDeleterMockRecorder) DeleteAll(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAll", reflect.TypeOf((*MockProcessDeleter)(nil).DeleteAll), ctx, exec)
}

// DeleteAllSlice mocks base method.
func (m *MockProcessDeleter) DeleteAllSlice(o models.ProcessSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAllSlice", o, ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAllSlice indicates an expected call of DeleteAllSlice.
func (mr *MockProcessDeleterMockRecorder) DeleteAllSlice(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllSlice", reflect.TypeOf((*MockProcessDeleter)(nil).DeleteAllSlice), o, ctx, exec)
}

// MockProcessReloader is a mock of ProcessReloader interface.
type MockProcessReloader struct {
	ctrl     *gomock.Controller
	recorder *MockProcessReloaderMockRecorder
}

// MockProcessReloaderMockRecorder is the mock recorder for MockProcessReloader.
type MockProcessReloaderMockRecorder struct {
	mock *MockProcessReloader
}

// NewMockProcessReloader creates a new mock instance.
func NewMockProcessReloader(ctrl *gomock.Controller) *MockProcessReloader {
	mock := &MockProcessReloader{ctrl: ctrl}
	mock.recorder = &MockProcessReloaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessReloader) EXPECT() *MockProcessReloaderMockRecorder {
	return m.recorder
}

// Reload mocks base method.
func (m *MockProcessReloader) Reload(o *models.Process, ctx context.Context, exec boil.ContextExecutor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reload", o, ctx, exec)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reload indicates an expected call of Reload.
func (mr *MockProcessReloaderMockRecorder) Reload(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reload", reflect.TypeOf((*MockProcessReloader)(nil).Reload), o, ctx, exec)
}

// ReloadAll mocks base method.
func (m *MockProcessReloader) ReloadAll(o *models.ProcessSlice, ctx context.Context, exec boil.ContextExecutor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReloadAll", o, ctx, exec)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReloadAll indicates an expected call of ReloadAll.
func (mr *MockProcessReloaderMockRecorder) ReloadAll(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReloadAll", reflect.TypeOf((*MockProcessReloader)(nil).ReloadAll), o, ctx, exec)
}
