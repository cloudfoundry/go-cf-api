// +build psql

//go:generate sh -c "echo '\x2bbuild unit' > ../../../../buildtags.txt && mockgen -source=$GOFILE -destination=mocks/processes.go -copyright_file=../../../../buildtags.txt && rm -f ../../../../buildtags.txt"
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

type ProcessUpserter interface {
	Upsert(o *Process, ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (q processQuery) Upsert(o *Process, ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no processes provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(processColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	processUpsertCacheMut.RLock()
	cache, cached := processUpsertCache[key]
	processUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			processAllColumns,
			processColumnsWithDefault,
			processColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			processAllColumns,
			processPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert processes, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(processPrimaryKeyColumns))
			copy(conflict, processPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"processes\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(processType, processMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(processType, processMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert processes")
	}

	if !cached {
		processUpsertCacheMut.Lock()
		processUpsertCache[key] = cache
		processUpsertCacheMut.Unlock()
	}

	return nil
}

// Process is an object representing the database table.
type Process struct {
	ID                             int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                           string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt                      time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                      null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Production                     null.Bool   `boil:"production" json:"production,omitempty" toml:"production" yaml:"production,omitempty"`
	Memory                         null.Int    `boil:"memory" json:"memory,omitempty" toml:"memory" yaml:"memory,omitempty"`
	Instances                      null.Int    `boil:"instances" json:"instances,omitempty" toml:"instances" yaml:"instances,omitempty"`
	FileDescriptors                null.Int    `boil:"file_descriptors" json:"file_descriptors,omitempty" toml:"file_descriptors" yaml:"file_descriptors,omitempty"`
	DiskQuota                      null.Int    `boil:"disk_quota" json:"disk_quota,omitempty" toml:"disk_quota" yaml:"disk_quota,omitempty"`
	State                          string      `boil:"state" json:"state" toml:"state" yaml:"state"`
	Version                        null.String `boil:"version" json:"version,omitempty" toml:"version" yaml:"version,omitempty"`
	Metadata                       string      `boil:"metadata" json:"metadata" toml:"metadata" yaml:"metadata"`
	DetectedBuildpack              null.String `boil:"detected_buildpack" json:"detected_buildpack,omitempty" toml:"detected_buildpack" yaml:"detected_buildpack,omitempty"`
	NotDeleted                     null.Bool   `boil:"not_deleted" json:"not_deleted,omitempty" toml:"not_deleted" yaml:"not_deleted,omitempty"`
	HealthCheckTimeout             null.Int    `boil:"health_check_timeout" json:"health_check_timeout,omitempty" toml:"health_check_timeout" yaml:"health_check_timeout,omitempty"`
	Diego                          null.Bool   `boil:"diego" json:"diego,omitempty" toml:"diego" yaml:"diego,omitempty"`
	PackageUpdatedAt               null.Time   `boil:"package_updated_at" json:"package_updated_at,omitempty" toml:"package_updated_at" yaml:"package_updated_at,omitempty"`
	AppGUID                        null.String `boil:"app_guid" json:"app_guid,omitempty" toml:"app_guid" yaml:"app_guid,omitempty"`
	Type                           null.String `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	HealthCheckType                null.String `boil:"health_check_type" json:"health_check_type,omitempty" toml:"health_check_type" yaml:"health_check_type,omitempty"`
	Command                        null.String `boil:"command" json:"command,omitempty" toml:"command" yaml:"command,omitempty"`
	EnableSSH                      null.Bool   `boil:"enable_ssh" json:"enable_ssh,omitempty" toml:"enable_ssh" yaml:"enable_ssh,omitempty"`
	EncryptedDockerCredentialsJSON null.String `boil:"encrypted_docker_credentials_json" json:"encrypted_docker_credentials_json,omitempty" toml:"encrypted_docker_credentials_json" yaml:"encrypted_docker_credentials_json,omitempty"`
	DockerSalt                     null.String `boil:"docker_salt" json:"docker_salt,omitempty" toml:"docker_salt" yaml:"docker_salt,omitempty"`
	Ports                          null.String `boil:"ports" json:"ports,omitempty" toml:"ports" yaml:"ports,omitempty"`
	HealthCheckHTTPEndpoint        null.String `boil:"health_check_http_endpoint" json:"health_check_http_endpoint,omitempty" toml:"health_check_http_endpoint" yaml:"health_check_http_endpoint,omitempty"`
	HealthCheckInvocationTimeout   null.Int    `boil:"health_check_invocation_timeout" json:"health_check_invocation_timeout,omitempty" toml:"health_check_invocation_timeout" yaml:"health_check_invocation_timeout,omitempty"`
	RevisionGUID                   null.String `boil:"revision_guid" json:"revision_guid,omitempty" toml:"revision_guid" yaml:"revision_guid,omitempty"`

	R *processR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L processL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ProcessColumns = struct {
	ID                             string
	GUID                           string
	CreatedAt                      string
	UpdatedAt                      string
	Production                     string
	Memory                         string
	Instances                      string
	FileDescriptors                string
	DiskQuota                      string
	State                          string
	Version                        string
	Metadata                       string
	DetectedBuildpack              string
	NotDeleted                     string
	HealthCheckTimeout             string
	Diego                          string
	PackageUpdatedAt               string
	AppGUID                        string
	Type                           string
	HealthCheckType                string
	Command                        string
	EnableSSH                      string
	EncryptedDockerCredentialsJSON string
	DockerSalt                     string
	Ports                          string
	HealthCheckHTTPEndpoint        string
	HealthCheckInvocationTimeout   string
	RevisionGUID                   string
}{
	ID:                             "id",
	GUID:                           "guid",
	CreatedAt:                      "created_at",
	UpdatedAt:                      "updated_at",
	Production:                     "production",
	Memory:                         "memory",
	Instances:                      "instances",
	FileDescriptors:                "file_descriptors",
	DiskQuota:                      "disk_quota",
	State:                          "state",
	Version:                        "version",
	Metadata:                       "metadata",
	DetectedBuildpack:              "detected_buildpack",
	NotDeleted:                     "not_deleted",
	HealthCheckTimeout:             "health_check_timeout",
	Diego:                          "diego",
	PackageUpdatedAt:               "package_updated_at",
	AppGUID:                        "app_guid",
	Type:                           "type",
	HealthCheckType:                "health_check_type",
	Command:                        "command",
	EnableSSH:                      "enable_ssh",
	EncryptedDockerCredentialsJSON: "encrypted_docker_credentials_json",
	DockerSalt:                     "docker_salt",
	Ports:                          "ports",
	HealthCheckHTTPEndpoint:        "health_check_http_endpoint",
	HealthCheckInvocationTimeout:   "health_check_invocation_timeout",
	RevisionGUID:                   "revision_guid",
}

var ProcessTableColumns = struct {
	ID                             string
	GUID                           string
	CreatedAt                      string
	UpdatedAt                      string
	Production                     string
	Memory                         string
	Instances                      string
	FileDescriptors                string
	DiskQuota                      string
	State                          string
	Version                        string
	Metadata                       string
	DetectedBuildpack              string
	NotDeleted                     string
	HealthCheckTimeout             string
	Diego                          string
	PackageUpdatedAt               string
	AppGUID                        string
	Type                           string
	HealthCheckType                string
	Command                        string
	EnableSSH                      string
	EncryptedDockerCredentialsJSON string
	DockerSalt                     string
	Ports                          string
	HealthCheckHTTPEndpoint        string
	HealthCheckInvocationTimeout   string
	RevisionGUID                   string
}{
	ID:                             "processes.id",
	GUID:                           "processes.guid",
	CreatedAt:                      "processes.created_at",
	UpdatedAt:                      "processes.updated_at",
	Production:                     "processes.production",
	Memory:                         "processes.memory",
	Instances:                      "processes.instances",
	FileDescriptors:                "processes.file_descriptors",
	DiskQuota:                      "processes.disk_quota",
	State:                          "processes.state",
	Version:                        "processes.version",
	Metadata:                       "processes.metadata",
	DetectedBuildpack:              "processes.detected_buildpack",
	NotDeleted:                     "processes.not_deleted",
	HealthCheckTimeout:             "processes.health_check_timeout",
	Diego:                          "processes.diego",
	PackageUpdatedAt:               "processes.package_updated_at",
	AppGUID:                        "processes.app_guid",
	Type:                           "processes.type",
	HealthCheckType:                "processes.health_check_type",
	Command:                        "processes.command",
	EnableSSH:                      "processes.enable_ssh",
	EncryptedDockerCredentialsJSON: "processes.encrypted_docker_credentials_json",
	DockerSalt:                     "processes.docker_salt",
	Ports:                          "processes.ports",
	HealthCheckHTTPEndpoint:        "processes.health_check_http_endpoint",
	HealthCheckInvocationTimeout:   "processes.health_check_invocation_timeout",
	RevisionGUID:                   "processes.revision_guid",
}

// Generated where

var ProcessWhere = struct {
	ID                             whereHelperint
	GUID                           whereHelperstring
	CreatedAt                      whereHelpertime_Time
	UpdatedAt                      whereHelpernull_Time
	Production                     whereHelpernull_Bool
	Memory                         whereHelpernull_Int
	Instances                      whereHelpernull_Int
	FileDescriptors                whereHelpernull_Int
	DiskQuota                      whereHelpernull_Int
	State                          whereHelperstring
	Version                        whereHelpernull_String
	Metadata                       whereHelperstring
	DetectedBuildpack              whereHelpernull_String
	NotDeleted                     whereHelpernull_Bool
	HealthCheckTimeout             whereHelpernull_Int
	Diego                          whereHelpernull_Bool
	PackageUpdatedAt               whereHelpernull_Time
	AppGUID                        whereHelpernull_String
	Type                           whereHelpernull_String
	HealthCheckType                whereHelpernull_String
	Command                        whereHelpernull_String
	EnableSSH                      whereHelpernull_Bool
	EncryptedDockerCredentialsJSON whereHelpernull_String
	DockerSalt                     whereHelpernull_String
	Ports                          whereHelpernull_String
	HealthCheckHTTPEndpoint        whereHelpernull_String
	HealthCheckInvocationTimeout   whereHelpernull_Int
	RevisionGUID                   whereHelpernull_String
}{
	ID:                             whereHelperint{field: "\"processes\".\"id\""},
	GUID:                           whereHelperstring{field: "\"processes\".\"guid\""},
	CreatedAt:                      whereHelpertime_Time{field: "\"processes\".\"created_at\""},
	UpdatedAt:                      whereHelpernull_Time{field: "\"processes\".\"updated_at\""},
	Production:                     whereHelpernull_Bool{field: "\"processes\".\"production\""},
	Memory:                         whereHelpernull_Int{field: "\"processes\".\"memory\""},
	Instances:                      whereHelpernull_Int{field: "\"processes\".\"instances\""},
	FileDescriptors:                whereHelpernull_Int{field: "\"processes\".\"file_descriptors\""},
	DiskQuota:                      whereHelpernull_Int{field: "\"processes\".\"disk_quota\""},
	State:                          whereHelperstring{field: "\"processes\".\"state\""},
	Version:                        whereHelpernull_String{field: "\"processes\".\"version\""},
	Metadata:                       whereHelperstring{field: "\"processes\".\"metadata\""},
	DetectedBuildpack:              whereHelpernull_String{field: "\"processes\".\"detected_buildpack\""},
	NotDeleted:                     whereHelpernull_Bool{field: "\"processes\".\"not_deleted\""},
	HealthCheckTimeout:             whereHelpernull_Int{field: "\"processes\".\"health_check_timeout\""},
	Diego:                          whereHelpernull_Bool{field: "\"processes\".\"diego\""},
	PackageUpdatedAt:               whereHelpernull_Time{field: "\"processes\".\"package_updated_at\""},
	AppGUID:                        whereHelpernull_String{field: "\"processes\".\"app_guid\""},
	Type:                           whereHelpernull_String{field: "\"processes\".\"type\""},
	HealthCheckType:                whereHelpernull_String{field: "\"processes\".\"health_check_type\""},
	Command:                        whereHelpernull_String{field: "\"processes\".\"command\""},
	EnableSSH:                      whereHelpernull_Bool{field: "\"processes\".\"enable_ssh\""},
	EncryptedDockerCredentialsJSON: whereHelpernull_String{field: "\"processes\".\"encrypted_docker_credentials_json\""},
	DockerSalt:                     whereHelpernull_String{field: "\"processes\".\"docker_salt\""},
	Ports:                          whereHelpernull_String{field: "\"processes\".\"ports\""},
	HealthCheckHTTPEndpoint:        whereHelpernull_String{field: "\"processes\".\"health_check_http_endpoint\""},
	HealthCheckInvocationTimeout:   whereHelpernull_Int{field: "\"processes\".\"health_check_invocation_timeout\""},
	RevisionGUID:                   whereHelpernull_String{field: "\"processes\".\"revision_guid\""},
}

// ProcessRels is where relationship names are stored.
var ProcessRels = struct {
	App                        string
	AppAppEvents               string
	ResourceProcessAnnotations string
	ResourceProcessLabels      string
}{
	App:                        "App",
	AppAppEvents:               "AppAppEvents",
	ResourceProcessAnnotations: "ResourceProcessAnnotations",
	ResourceProcessLabels:      "ResourceProcessLabels",
}

// processR is where relationships are stored.
type processR struct {
	App                        *App                   `boil:"App" json:"App" toml:"App" yaml:"App"`
	AppAppEvents               AppEventSlice          `boil:"AppAppEvents" json:"AppAppEvents" toml:"AppAppEvents" yaml:"AppAppEvents"`
	ResourceProcessAnnotations ProcessAnnotationSlice `boil:"ResourceProcessAnnotations" json:"ResourceProcessAnnotations" toml:"ResourceProcessAnnotations" yaml:"ResourceProcessAnnotations"`
	ResourceProcessLabels      ProcessLabelSlice      `boil:"ResourceProcessLabels" json:"ResourceProcessLabels" toml:"ResourceProcessLabels" yaml:"ResourceProcessLabels"`
}

// NewStruct creates a new relationship struct
func (*processR) NewStruct() *processR {
	return &processR{}
}

// processL is where Load methods for each relationship are stored.
type processL struct{}

var (
	processAllColumns            = []string{"id", "guid", "created_at", "updated_at", "production", "memory", "instances", "file_descriptors", "disk_quota", "state", "version", "metadata", "detected_buildpack", "not_deleted", "health_check_timeout", "diego", "package_updated_at", "app_guid", "type", "health_check_type", "command", "enable_ssh", "encrypted_docker_credentials_json", "docker_salt", "ports", "health_check_http_endpoint", "health_check_invocation_timeout", "revision_guid"}
	processColumnsWithoutDefault = []string{"guid", "updated_at", "memory", "version", "detected_buildpack", "health_check_timeout", "package_updated_at", "app_guid", "command", "encrypted_docker_credentials_json", "docker_salt", "ports", "health_check_http_endpoint", "health_check_invocation_timeout", "revision_guid"}
	processColumnsWithDefault    = []string{"id", "created_at", "production", "instances", "file_descriptors", "disk_quota", "state", "metadata", "not_deleted", "diego", "type", "health_check_type", "enable_ssh"}
	processPrimaryKeyColumns     = []string{"id"}
)

type (
	// ProcessSlice is an alias for a slice of pointers to Process.
	// This should almost always be used instead of []Process.
	ProcessSlice []*Process

	processQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	processType                 = reflect.TypeOf(&Process{})
	processMapping              = queries.MakeStructMapping(processType)
	processPrimaryKeyMapping, _ = queries.BindMapping(processType, processMapping, processPrimaryKeyColumns)
	processInsertCacheMut       sync.RWMutex
	processInsertCache          = make(map[string]insertCache)
	processUpdateCacheMut       sync.RWMutex
	processUpdateCache          = make(map[string]updateCache)
	processUpsertCacheMut       sync.RWMutex
	processUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type ProcessFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*Process, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (ProcessSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single process record from the query.
func (q processQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Process, error) {
	o := &Process{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for processes")
	}

	return o, nil
}

// All returns all Process records from the query.
func (q processQuery) All(ctx context.Context, exec boil.ContextExecutor) (ProcessSlice, error) {
	var o []*Process

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Process slice")
	}

	return o, nil
}

// Count returns the count of all Process records in the query.
func (q processQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count processes rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q processQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if processes exists")
	}

	return count > 0, nil
}

// App pointed to by the foreign key.
func (q processQuery) App(o *Process, mods ...qm.QueryMod) appQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"guid\" = ?", o.AppGUID),
	}

	queryMods = append(queryMods, mods...)

	query := Apps(queryMods...)
	queries.SetFrom(query.Query, "\"apps\"")

	return query
}

// AppAppEvents retrieves all the app_event's AppEvents with an executor via app_id column.
func (q processQuery) AppAppEvents(o *Process, mods ...qm.QueryMod) appEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"app_events\".\"app_id\"=?", o.ID),
	)

	query := AppEvents(queryMods...)
	queries.SetFrom(query.Query, "\"app_events\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"app_events\".*"})
	}

	return query
}

// ResourceProcessAnnotations retrieves all the process_annotation's ProcessAnnotations with an executor via resource_guid column.
func (q processQuery) ResourceProcessAnnotations(o *Process, mods ...qm.QueryMod) processAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"process_annotations\".\"resource_guid\"=?", o.GUID),
	)

	query := ProcessAnnotations(queryMods...)
	queries.SetFrom(query.Query, "\"process_annotations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"process_annotations\".*"})
	}

	return query
}

// ResourceProcessLabels retrieves all the process_label's ProcessLabels with an executor via resource_guid column.
func (q processQuery) ResourceProcessLabels(o *Process, mods ...qm.QueryMod) processLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"process_labels\".\"resource_guid\"=?", o.GUID),
	)

	query := ProcessLabels(queryMods...)
	queries.SetFrom(query.Query, "\"process_labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"process_labels\".*"})
	}

	return query
}

// LoadApp allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (processL) LoadApp(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProcess interface{}, mods queries.Applicator) error {
	var slice []*Process
	var object *Process

	if singular {
		object = maybeProcess.(*Process)
	} else {
		slice = *maybeProcess.(*[]*Process)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &processR{}
		}
		if !queries.IsNil(object.AppGUID) {
			args = append(args, object.AppGUID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &processR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AppGUID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AppGUID) {
				args = append(args, obj.AppGUID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`apps`),
		qm.WhereIn(`apps.guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load App")
	}

	var resultSlice []*App
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice App")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for apps")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for apps")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.App = foreign
		if foreign.R == nil {
			foreign.R = &appR{}
		}
		foreign.R.Processes = append(foreign.R.Processes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AppGUID, foreign.GUID) {
				local.R.App = foreign
				if foreign.R == nil {
					foreign.R = &appR{}
				}
				foreign.R.Processes = append(foreign.R.Processes, local)
				break
			}
		}
	}

	return nil
}

// LoadAppAppEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (processL) LoadAppAppEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProcess interface{}, mods queries.Applicator) error {
	var slice []*Process
	var object *Process

	if singular {
		object = maybeProcess.(*Process)
	} else {
		slice = *maybeProcess.(*[]*Process)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &processR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &processR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`app_events`),
		qm.WhereIn(`app_events.app_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load app_events")
	}

	var resultSlice []*AppEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice app_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on app_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for app_events")
	}

	if singular {
		object.R.AppAppEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &appEventR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.AppID {
				local.R.AppAppEvents = append(local.R.AppAppEvents, foreign)
				if foreign.R == nil {
					foreign.R = &appEventR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadResourceProcessAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (processL) LoadResourceProcessAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProcess interface{}, mods queries.Applicator) error {
	var slice []*Process
	var object *Process

	if singular {
		object = maybeProcess.(*Process)
	} else {
		slice = *maybeProcess.(*[]*Process)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &processR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &processR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`process_annotations`),
		qm.WhereIn(`process_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load process_annotations")
	}

	var resultSlice []*ProcessAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice process_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on process_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for process_annotations")
	}

	if singular {
		object.R.ResourceProcessAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &processAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceProcessAnnotations = append(local.R.ResourceProcessAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &processAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceProcessLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (processL) LoadResourceProcessLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProcess interface{}, mods queries.Applicator) error {
	var slice []*Process
	var object *Process

	if singular {
		object = maybeProcess.(*Process)
	} else {
		slice = *maybeProcess.(*[]*Process)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &processR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &processR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`process_labels`),
		qm.WhereIn(`process_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load process_labels")
	}

	var resultSlice []*ProcessLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice process_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on process_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for process_labels")
	}

	if singular {
		object.R.ResourceProcessLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &processLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceProcessLabels = append(local.R.ResourceProcessLabels, foreign)
				if foreign.R == nil {
					foreign.R = &processLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// SetApp of the process to the related item.
// Sets o.R.App to related.
// Adds o to related.R.Processes.
func (q processQuery) SetApp(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related *App) error {
	var err error
	if insert {
		if err = Apps().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"processes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"app_guid"}),
		strmangle.WhereClause("\"", "\"", 2, processPrimaryKeyColumns),
	)
	values := []interface{}{related.GUID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AppGUID, related.GUID)
	if o.R == nil {
		o.R = &processR{
			App: related,
		}
	} else {
		o.R.App = related
	}

	if related.R == nil {
		related.R = &appR{
			Processes: ProcessSlice{o},
		}
	} else {
		related.R.Processes = append(related.R.Processes, o)
	}

	return nil
}

// RemoveApp relationship.
// Sets o.R.App to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (q processQuery) RemoveApp(o *Process, ctx context.Context, exec boil.ContextExecutor, related *App) error {
	var err error

	queries.SetScanner(&o.AppGUID, nil)
	if _, err = q.Update(o, ctx, exec, boil.Whitelist("app_guid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.App = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Processes {
		if queries.Equal(o.AppGUID, ri.AppGUID) {
			continue
		}

		ln := len(related.R.Processes)
		if ln > 1 && i < ln-1 {
			related.R.Processes[i] = related.R.Processes[ln-1]
		}
		related.R.Processes = related.R.Processes[:ln-1]
		break
	}
	return nil
}

// AddAppAppEvents adds the given related objects to the existing relationships
// of the process, optionally inserting them as new records.
// Appends related to o.R.AppAppEvents.
// Sets related.R.App appropriately.
func (q processQuery) AddAppAppEvents(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AppEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AppID = o.ID
			if err = AppEvents().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"app_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"app_id"}),
				strmangle.WhereClause("\"", "\"", 2, appEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AppID = o.ID
		}
	}

	if o.R == nil {
		o.R = &processR{
			AppAppEvents: related,
		}
	} else {
		o.R.AppAppEvents = append(o.R.AppAppEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &appEventR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// AddResourceProcessAnnotations adds the given related objects to the existing relationships
// of the process, optionally inserting them as new records.
// Appends related to o.R.ResourceProcessAnnotations.
// Sets related.R.Resource appropriately.
func (q processQuery) AddResourceProcessAnnotations(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProcessAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ProcessAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"process_annotations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, processAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &processR{
			ResourceProcessAnnotations: related,
		}
	} else {
		o.R.ResourceProcessAnnotations = append(o.R.ResourceProcessAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &processAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceProcessAnnotations removes all previously related items of the
// process replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceProcessAnnotations accordingly.
// Replaces o.R.ResourceProcessAnnotations with related.
// Sets related.R.Resource's ResourceProcessAnnotations accordingly.
func (q processQuery) SetResourceProcessAnnotations(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProcessAnnotation) error {
	query := "update \"process_annotations\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceProcessAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceProcessAnnotations = nil
	}
	return q.AddResourceProcessAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourceProcessAnnotations relationships from objects passed in.
// Removes related items from R.ResourceProcessAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q processQuery) RemoveResourceProcessAnnotations(o *Process, ctx context.Context, exec boil.ContextExecutor, related ...*ProcessAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ProcessAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceProcessAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceProcessAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceProcessAnnotations[i] = o.R.ResourceProcessAnnotations[ln-1]
			}
			o.R.ResourceProcessAnnotations = o.R.ResourceProcessAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceProcessLabels adds the given related objects to the existing relationships
// of the process, optionally inserting them as new records.
// Appends related to o.R.ResourceProcessLabels.
// Sets related.R.Resource appropriately.
func (q processQuery) AddResourceProcessLabels(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProcessLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ProcessLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"process_labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, processLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &processR{
			ResourceProcessLabels: related,
		}
	} else {
		o.R.ResourceProcessLabels = append(o.R.ResourceProcessLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &processLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceProcessLabels removes all previously related items of the
// process replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceProcessLabels accordingly.
// Replaces o.R.ResourceProcessLabels with related.
// Sets related.R.Resource's ResourceProcessLabels accordingly.
func (q processQuery) SetResourceProcessLabels(o *Process, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProcessLabel) error {
	query := "update \"process_labels\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceProcessLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceProcessLabels = nil
	}
	return q.AddResourceProcessLabels(o, ctx, exec, insert, related...)
}

// RemoveResourceProcessLabels relationships from objects passed in.
// Removes related items from R.ResourceProcessLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q processQuery) RemoveResourceProcessLabels(o *Process, ctx context.Context, exec boil.ContextExecutor, related ...*ProcessLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ProcessLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceProcessLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceProcessLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceProcessLabels[i] = o.R.ResourceProcessLabels[ln-1]
			}
			o.R.ResourceProcessLabels = o.R.ResourceProcessLabels[:ln-1]
			break
		}
	}

	return nil
}

// Processes retrieves all the records using an executor.
func Processes(mods ...qm.QueryMod) processQuery {
	mods = append(mods, qm.From("\"processes\""))
	return processQuery{NewQuery(mods...)}
}

type ProcessFinder interface {
	FindProcess(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Process, error)
}

// FindProcess retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindProcess(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Process, error) {
	processObj := &Process{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"processes\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, processObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from processes")
	}

	return processObj, nil
}

type ProcessInserter interface {
	Insert(o *Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q processQuery) Insert(o *Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no processes provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(processColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	processInsertCacheMut.RLock()
	cache, cached := processInsertCache[key]
	processInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			processAllColumns,
			processColumnsWithDefault,
			processColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(processType, processMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(processType, processMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"processes\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"processes\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into processes")
	}

	if !cached {
		processInsertCacheMut.Lock()
		processInsertCache[key] = cache
		processInsertCacheMut.Unlock()
	}

	return nil
}

type ProcessUpdater interface {
	Update(o *Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o ProcessSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the Process.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q processQuery) Update(o *Process, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	processUpdateCacheMut.RLock()
	cache, cached := processUpdateCache[key]
	processUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			processAllColumns,
			processPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update processes, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"processes\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, processPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(processType, processMapping, append(wl, processPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update processes row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for processes")
	}

	if !cached {
		processUpdateCacheMut.Lock()
		processUpdateCache[key] = cache
		processUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q processQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for processes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for processes")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q processQuery) UpdateAllSlice(o ProcessSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), processPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"processes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, processPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in process slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all process")
	}
	return rowsAff, nil
}

type ProcessDeleter interface {
	Delete(o *Process, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o ProcessSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single Process record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q processQuery) Delete(o *Process, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Process provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), processPrimaryKeyMapping)
	sql := "DELETE FROM \"processes\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from processes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for processes")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q processQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no processQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from processes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for processes")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q processQuery) DeleteAllSlice(o ProcessSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), processPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"processes\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, processPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from process slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for processes")
	}

	return rowsAff, nil
}

type ProcessReloader interface {
	Reload(o *Process, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *ProcessSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q processQuery) Reload(o *Process, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindProcess(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q processQuery) ReloadAll(o *ProcessSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ProcessSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), processPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"processes\".* FROM \"processes\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, processPrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ProcessSlice")
	}

	*o = slice

	return nil
}

// ProcessExists checks if the Process row exists.
func ProcessExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"processes\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if processes exists")
	}

	return exists, nil
}
