// +build postgres
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Service is an object representing the database table.
type Service struct {
	ID                   int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                 string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt            time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt            null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Label                string      `boil:"label" json:"label" toml:"label" yaml:"label"`
	Description          string      `boil:"description" json:"description" toml:"description" yaml:"description"`
	InfoURL              null.String `boil:"info_url" json:"info_url,omitempty" toml:"info_url" yaml:"info_url,omitempty"`
	Acls                 null.String `boil:"acls" json:"acls,omitempty" toml:"acls" yaml:"acls,omitempty"`
	Timeout              null.Int    `boil:"timeout" json:"timeout,omitempty" toml:"timeout" yaml:"timeout,omitempty"`
	Active               null.Bool   `boil:"active" json:"active,omitempty" toml:"active" yaml:"active,omitempty"`
	Extra                null.String `boil:"extra" json:"extra,omitempty" toml:"extra" yaml:"extra,omitempty"`
	UniqueID             null.String `boil:"unique_id" json:"unique_id,omitempty" toml:"unique_id" yaml:"unique_id,omitempty"`
	Bindable             bool        `boil:"bindable" json:"bindable" toml:"bindable" yaml:"bindable"`
	Tags                 null.String `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	DocumentationURL     null.String `boil:"documentation_url" json:"documentation_url,omitempty" toml:"documentation_url" yaml:"documentation_url,omitempty"`
	ServiceBrokerID      null.Int    `boil:"service_broker_id" json:"service_broker_id,omitempty" toml:"service_broker_id" yaml:"service_broker_id,omitempty"`
	LongDescription      null.String `boil:"long_description" json:"long_description,omitempty" toml:"long_description" yaml:"long_description,omitempty"`
	Requires             null.String `boil:"requires" json:"requires,omitempty" toml:"requires" yaml:"requires,omitempty"`
	Purging              bool        `boil:"purging" json:"purging" toml:"purging" yaml:"purging"`
	PlanUpdateable       null.Bool   `boil:"plan_updateable" json:"plan_updateable,omitempty" toml:"plan_updateable" yaml:"plan_updateable,omitempty"`
	BindingsRetrievable  bool        `boil:"bindings_retrievable" json:"bindings_retrievable" toml:"bindings_retrievable" yaml:"bindings_retrievable"`
	InstancesRetrievable bool        `boil:"instances_retrievable" json:"instances_retrievable" toml:"instances_retrievable" yaml:"instances_retrievable"`
	AllowContextUpdates  bool        `boil:"allow_context_updates" json:"allow_context_updates" toml:"allow_context_updates" yaml:"allow_context_updates"`

	R *serviceR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L serviceL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ServiceColumns = struct {
	ID                   string
	GUID                 string
	CreatedAt            string
	UpdatedAt            string
	Label                string
	Description          string
	InfoURL              string
	Acls                 string
	Timeout              string
	Active               string
	Extra                string
	UniqueID             string
	Bindable             string
	Tags                 string
	DocumentationURL     string
	ServiceBrokerID      string
	LongDescription      string
	Requires             string
	Purging              string
	PlanUpdateable       string
	BindingsRetrievable  string
	InstancesRetrievable string
	AllowContextUpdates  string
}{
	ID:                   "id",
	GUID:                 "guid",
	CreatedAt:            "created_at",
	UpdatedAt:            "updated_at",
	Label:                "label",
	Description:          "description",
	InfoURL:              "info_url",
	Acls:                 "acls",
	Timeout:              "timeout",
	Active:               "active",
	Extra:                "extra",
	UniqueID:             "unique_id",
	Bindable:             "bindable",
	Tags:                 "tags",
	DocumentationURL:     "documentation_url",
	ServiceBrokerID:      "service_broker_id",
	LongDescription:      "long_description",
	Requires:             "requires",
	Purging:              "purging",
	PlanUpdateable:       "plan_updateable",
	BindingsRetrievable:  "bindings_retrievable",
	InstancesRetrievable: "instances_retrievable",
	AllowContextUpdates:  "allow_context_updates",
}

var ServiceTableColumns = struct {
	ID                   string
	GUID                 string
	CreatedAt            string
	UpdatedAt            string
	Label                string
	Description          string
	InfoURL              string
	Acls                 string
	Timeout              string
	Active               string
	Extra                string
	UniqueID             string
	Bindable             string
	Tags                 string
	DocumentationURL     string
	ServiceBrokerID      string
	LongDescription      string
	Requires             string
	Purging              string
	PlanUpdateable       string
	BindingsRetrievable  string
	InstancesRetrievable string
	AllowContextUpdates  string
}{
	ID:                   "services.id",
	GUID:                 "services.guid",
	CreatedAt:            "services.created_at",
	UpdatedAt:            "services.updated_at",
	Label:                "services.label",
	Description:          "services.description",
	InfoURL:              "services.info_url",
	Acls:                 "services.acls",
	Timeout:              "services.timeout",
	Active:               "services.active",
	Extra:                "services.extra",
	UniqueID:             "services.unique_id",
	Bindable:             "services.bindable",
	Tags:                 "services.tags",
	DocumentationURL:     "services.documentation_url",
	ServiceBrokerID:      "services.service_broker_id",
	LongDescription:      "services.long_description",
	Requires:             "services.requires",
	Purging:              "services.purging",
	PlanUpdateable:       "services.plan_updateable",
	BindingsRetrievable:  "services.bindings_retrievable",
	InstancesRetrievable: "services.instances_retrievable",
	AllowContextUpdates:  "services.allow_context_updates",
}

// Generated where

var ServiceWhere = struct {
	ID                   whereHelperint
	GUID                 whereHelperstring
	CreatedAt            whereHelpertime_Time
	UpdatedAt            whereHelpernull_Time
	Label                whereHelperstring
	Description          whereHelperstring
	InfoURL              whereHelpernull_String
	Acls                 whereHelpernull_String
	Timeout              whereHelpernull_Int
	Active               whereHelpernull_Bool
	Extra                whereHelpernull_String
	UniqueID             whereHelpernull_String
	Bindable             whereHelperbool
	Tags                 whereHelpernull_String
	DocumentationURL     whereHelpernull_String
	ServiceBrokerID      whereHelpernull_Int
	LongDescription      whereHelpernull_String
	Requires             whereHelpernull_String
	Purging              whereHelperbool
	PlanUpdateable       whereHelpernull_Bool
	BindingsRetrievable  whereHelperbool
	InstancesRetrievable whereHelperbool
	AllowContextUpdates  whereHelperbool
}{
	ID:                   whereHelperint{field: "\"services\".\"id\""},
	GUID:                 whereHelperstring{field: "\"services\".\"guid\""},
	CreatedAt:            whereHelpertime_Time{field: "\"services\".\"created_at\""},
	UpdatedAt:            whereHelpernull_Time{field: "\"services\".\"updated_at\""},
	Label:                whereHelperstring{field: "\"services\".\"label\""},
	Description:          whereHelperstring{field: "\"services\".\"description\""},
	InfoURL:              whereHelpernull_String{field: "\"services\".\"info_url\""},
	Acls:                 whereHelpernull_String{field: "\"services\".\"acls\""},
	Timeout:              whereHelpernull_Int{field: "\"services\".\"timeout\""},
	Active:               whereHelpernull_Bool{field: "\"services\".\"active\""},
	Extra:                whereHelpernull_String{field: "\"services\".\"extra\""},
	UniqueID:             whereHelpernull_String{field: "\"services\".\"unique_id\""},
	Bindable:             whereHelperbool{field: "\"services\".\"bindable\""},
	Tags:                 whereHelpernull_String{field: "\"services\".\"tags\""},
	DocumentationURL:     whereHelpernull_String{field: "\"services\".\"documentation_url\""},
	ServiceBrokerID:      whereHelpernull_Int{field: "\"services\".\"service_broker_id\""},
	LongDescription:      whereHelpernull_String{field: "\"services\".\"long_description\""},
	Requires:             whereHelpernull_String{field: "\"services\".\"requires\""},
	Purging:              whereHelperbool{field: "\"services\".\"purging\""},
	PlanUpdateable:       whereHelpernull_Bool{field: "\"services\".\"plan_updateable\""},
	BindingsRetrievable:  whereHelperbool{field: "\"services\".\"bindings_retrievable\""},
	InstancesRetrievable: whereHelperbool{field: "\"services\".\"instances_retrievable\""},
	AllowContextUpdates:  whereHelperbool{field: "\"services\".\"allow_context_updates\""},
}

// ServiceRels is where relationship names are stored.
var ServiceRels = struct {
	ServiceBroker                      string
	ResourceServiceOfferingAnnotations string
	ResourceServiceOfferingLabels      string
	ServicePlans                       string
}{
	ServiceBroker:                      "ServiceBroker",
	ResourceServiceOfferingAnnotations: "ResourceServiceOfferingAnnotations",
	ResourceServiceOfferingLabels:      "ResourceServiceOfferingLabels",
	ServicePlans:                       "ServicePlans",
}

// serviceR is where relationships are stored.
type serviceR struct {
	ServiceBroker                      *ServiceBroker                 `boil:"ServiceBroker" json:"ServiceBroker" toml:"ServiceBroker" yaml:"ServiceBroker"`
	ResourceServiceOfferingAnnotations ServiceOfferingAnnotationSlice `boil:"ResourceServiceOfferingAnnotations" json:"ResourceServiceOfferingAnnotations" toml:"ResourceServiceOfferingAnnotations" yaml:"ResourceServiceOfferingAnnotations"`
	ResourceServiceOfferingLabels      ServiceOfferingLabelSlice      `boil:"ResourceServiceOfferingLabels" json:"ResourceServiceOfferingLabels" toml:"ResourceServiceOfferingLabels" yaml:"ResourceServiceOfferingLabels"`
	ServicePlans                       ServicePlanSlice               `boil:"ServicePlans" json:"ServicePlans" toml:"ServicePlans" yaml:"ServicePlans"`
}

// NewStruct creates a new relationship struct
func (*serviceR) NewStruct() *serviceR {
	return &serviceR{}
}

// serviceL is where Load methods for each relationship are stored.
type serviceL struct{}

var (
	serviceAllColumns            = []string{"id", "guid", "created_at", "updated_at", "label", "description", "info_url", "acls", "timeout", "active", "extra", "unique_id", "bindable", "tags", "documentation_url", "service_broker_id", "long_description", "requires", "purging", "plan_updateable", "bindings_retrievable", "instances_retrievable", "allow_context_updates"}
	serviceColumnsWithoutDefault = []string{"guid", "updated_at", "label", "description", "info_url", "acls", "timeout", "extra", "unique_id", "bindable", "tags", "documentation_url", "service_broker_id", "long_description", "requires"}
	serviceColumnsWithDefault    = []string{"id", "created_at", "active", "purging", "plan_updateable", "bindings_retrievable", "instances_retrievable", "allow_context_updates"}
	servicePrimaryKeyColumns     = []string{"id"}
)

type (
	// ServiceSlice is an alias for a slice of pointers to Service.
	// This should almost always be used instead of []Service.
	ServiceSlice []*Service
	// ServiceHook is the signature for custom Service hook methods
	ServiceHook func(context.Context, boil.ContextExecutor, *Service) error

	serviceQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	serviceType                 = reflect.TypeOf(&Service{})
	serviceMapping              = queries.MakeStructMapping(serviceType)
	servicePrimaryKeyMapping, _ = queries.BindMapping(serviceType, serviceMapping, servicePrimaryKeyColumns)
	serviceInsertCacheMut       sync.RWMutex
	serviceInsertCache          = make(map[string]insertCache)
	serviceUpdateCacheMut       sync.RWMutex
	serviceUpdateCache          = make(map[string]updateCache)
	serviceUpsertCacheMut       sync.RWMutex
	serviceUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var serviceBeforeInsertHooks []ServiceHook
var serviceBeforeUpdateHooks []ServiceHook
var serviceBeforeDeleteHooks []ServiceHook
var serviceBeforeUpsertHooks []ServiceHook

var serviceAfterInsertHooks []ServiceHook
var serviceAfterSelectHooks []ServiceHook
var serviceAfterUpdateHooks []ServiceHook
var serviceAfterDeleteHooks []ServiceHook
var serviceAfterUpsertHooks []ServiceHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Service) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Service) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Service) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Service) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Service) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Service) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Service) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Service) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Service) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range serviceAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddServiceHook registers your hook function for all future operations.
func AddServiceHook(hookPoint boil.HookPoint, serviceHook ServiceHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		serviceBeforeInsertHooks = append(serviceBeforeInsertHooks, serviceHook)
	case boil.BeforeUpdateHook:
		serviceBeforeUpdateHooks = append(serviceBeforeUpdateHooks, serviceHook)
	case boil.BeforeDeleteHook:
		serviceBeforeDeleteHooks = append(serviceBeforeDeleteHooks, serviceHook)
	case boil.BeforeUpsertHook:
		serviceBeforeUpsertHooks = append(serviceBeforeUpsertHooks, serviceHook)
	case boil.AfterInsertHook:
		serviceAfterInsertHooks = append(serviceAfterInsertHooks, serviceHook)
	case boil.AfterSelectHook:
		serviceAfterSelectHooks = append(serviceAfterSelectHooks, serviceHook)
	case boil.AfterUpdateHook:
		serviceAfterUpdateHooks = append(serviceAfterUpdateHooks, serviceHook)
	case boil.AfterDeleteHook:
		serviceAfterDeleteHooks = append(serviceAfterDeleteHooks, serviceHook)
	case boil.AfterUpsertHook:
		serviceAfterUpsertHooks = append(serviceAfterUpsertHooks, serviceHook)
	}
}

// One returns a single service record from the query.
func (q serviceQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Service, error) {
	o := &Service{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for services")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Service records from the query.
func (q serviceQuery) All(ctx context.Context, exec boil.ContextExecutor) (ServiceSlice, error) {
	var o []*Service

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Service slice")
	}

	if len(serviceAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Service records in the query.
func (q serviceQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count services rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q serviceQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if services exists")
	}

	return count > 0, nil
}

// ServiceBroker pointed to by the foreign key.
func (o *Service) ServiceBroker(mods ...qm.QueryMod) serviceBrokerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ServiceBrokerID),
	}

	queryMods = append(queryMods, mods...)

	query := ServiceBrokers(queryMods...)
	queries.SetFrom(query.Query, "\"service_brokers\"")

	return query
}

// ResourceServiceOfferingAnnotations retrieves all the service_offering_annotation's ServiceOfferingAnnotations with an executor via resource_guid column.
func (o *Service) ResourceServiceOfferingAnnotations(mods ...qm.QueryMod) serviceOfferingAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_offering_annotations\".\"resource_guid\"=?", o.GUID),
	)

	query := ServiceOfferingAnnotations(queryMods...)
	queries.SetFrom(query.Query, "\"service_offering_annotations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_offering_annotations\".*"})
	}

	return query
}

// ResourceServiceOfferingLabels retrieves all the service_offering_label's ServiceOfferingLabels with an executor via resource_guid column.
func (o *Service) ResourceServiceOfferingLabels(mods ...qm.QueryMod) serviceOfferingLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_offering_labels\".\"resource_guid\"=?", o.GUID),
	)

	query := ServiceOfferingLabels(queryMods...)
	queries.SetFrom(query.Query, "\"service_offering_labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_offering_labels\".*"})
	}

	return query
}

// ServicePlans retrieves all the service_plan's ServicePlans with an executor.
func (o *Service) ServicePlans(mods ...qm.QueryMod) servicePlanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_plans\".\"service_id\"=?", o.ID),
	)

	query := ServicePlans(queryMods...)
	queries.SetFrom(query.Query, "\"service_plans\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_plans\".*"})
	}

	return query
}

// LoadServiceBroker allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (serviceL) LoadServiceBroker(ctx context.Context, e boil.ContextExecutor, singular bool, maybeService interface{}, mods queries.Applicator) error {
	var slice []*Service
	var object *Service

	if singular {
		object = maybeService.(*Service)
	} else {
		slice = *maybeService.(*[]*Service)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceR{}
		}
		if !queries.IsNil(object.ServiceBrokerID) {
			args = append(args, object.ServiceBrokerID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ServiceBrokerID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ServiceBrokerID) {
				args = append(args, obj.ServiceBrokerID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_brokers`),
		qm.WhereIn(`service_brokers.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ServiceBroker")
	}

	var resultSlice []*ServiceBroker
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ServiceBroker")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for service_brokers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_brokers")
	}

	if len(serviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ServiceBroker = foreign
		if foreign.R == nil {
			foreign.R = &serviceBrokerR{}
		}
		foreign.R.Services = append(foreign.R.Services, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ServiceBrokerID, foreign.ID) {
				local.R.ServiceBroker = foreign
				if foreign.R == nil {
					foreign.R = &serviceBrokerR{}
				}
				foreign.R.Services = append(foreign.R.Services, local)
				break
			}
		}
	}

	return nil
}

// LoadResourceServiceOfferingAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceL) LoadResourceServiceOfferingAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeService interface{}, mods queries.Applicator) error {
	var slice []*Service
	var object *Service

	if singular {
		object = maybeService.(*Service)
	} else {
		slice = *maybeService.(*[]*Service)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_offering_annotations`),
		qm.WhereIn(`service_offering_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_offering_annotations")
	}

	var resultSlice []*ServiceOfferingAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_offering_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_offering_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_offering_annotations")
	}

	if len(serviceOfferingAnnotationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ResourceServiceOfferingAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceOfferingAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServiceOfferingAnnotations = append(local.R.ResourceServiceOfferingAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &serviceOfferingAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceServiceOfferingLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceL) LoadResourceServiceOfferingLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeService interface{}, mods queries.Applicator) error {
	var slice []*Service
	var object *Service

	if singular {
		object = maybeService.(*Service)
	} else {
		slice = *maybeService.(*[]*Service)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_offering_labels`),
		qm.WhereIn(`service_offering_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_offering_labels")
	}

	var resultSlice []*ServiceOfferingLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_offering_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_offering_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_offering_labels")
	}

	if len(serviceOfferingLabelAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ResourceServiceOfferingLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceOfferingLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServiceOfferingLabels = append(local.R.ResourceServiceOfferingLabels, foreign)
				if foreign.R == nil {
					foreign.R = &serviceOfferingLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadServicePlans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceL) LoadServicePlans(ctx context.Context, e boil.ContextExecutor, singular bool, maybeService interface{}, mods queries.Applicator) error {
	var slice []*Service
	var object *Service

	if singular {
		object = maybeService.(*Service)
	} else {
		slice = *maybeService.(*[]*Service)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_plans`),
		qm.WhereIn(`service_plans.service_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_plans")
	}

	var resultSlice []*ServicePlan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_plans")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_plans")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_plans")
	}

	if len(servicePlanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ServicePlans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &servicePlanR{}
			}
			foreign.R.Service = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ServiceID {
				local.R.ServicePlans = append(local.R.ServicePlans, foreign)
				if foreign.R == nil {
					foreign.R = &servicePlanR{}
				}
				foreign.R.Service = local
				break
			}
		}
	}

	return nil
}

// SetServiceBroker of the service to the related item.
// Sets o.R.ServiceBroker to related.
// Adds o to related.R.Services.
func (o *Service) SetServiceBroker(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ServiceBroker) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"services\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"service_broker_id"}),
		strmangle.WhereClause("\"", "\"", 2, servicePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ServiceBrokerID, related.ID)
	if o.R == nil {
		o.R = &serviceR{
			ServiceBroker: related,
		}
	} else {
		o.R.ServiceBroker = related
	}

	if related.R == nil {
		related.R = &serviceBrokerR{
			Services: ServiceSlice{o},
		}
	} else {
		related.R.Services = append(related.R.Services, o)
	}

	return nil
}

// RemoveServiceBroker relationship.
// Sets o.R.ServiceBroker to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Service) RemoveServiceBroker(ctx context.Context, exec boil.ContextExecutor, related *ServiceBroker) error {
	var err error

	queries.SetScanner(&o.ServiceBrokerID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("service_broker_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ServiceBroker = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Services {
		if queries.Equal(o.ServiceBrokerID, ri.ServiceBrokerID) {
			continue
		}

		ln := len(related.R.Services)
		if ln > 1 && i < ln-1 {
			related.R.Services[i] = related.R.Services[ln-1]
		}
		related.R.Services = related.R.Services[:ln-1]
		break
	}
	return nil
}

// AddResourceServiceOfferingAnnotations adds the given related objects to the existing relationships
// of the service, optionally inserting them as new records.
// Appends related to o.R.ResourceServiceOfferingAnnotations.
// Sets related.R.Resource appropriately.
func (o *Service) AddResourceServiceOfferingAnnotations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceOfferingAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_offering_annotations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, serviceOfferingAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &serviceR{
			ResourceServiceOfferingAnnotations: related,
		}
	} else {
		o.R.ResourceServiceOfferingAnnotations = append(o.R.ResourceServiceOfferingAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceOfferingAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServiceOfferingAnnotations removes all previously related items of the
// service replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServiceOfferingAnnotations accordingly.
// Replaces o.R.ResourceServiceOfferingAnnotations with related.
// Sets related.R.Resource's ResourceServiceOfferingAnnotations accordingly.
func (o *Service) SetResourceServiceOfferingAnnotations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceOfferingAnnotation) error {
	query := "update \"service_offering_annotations\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServiceOfferingAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServiceOfferingAnnotations = nil
	}
	return o.AddResourceServiceOfferingAnnotations(ctx, exec, insert, related...)
}

// RemoveResourceServiceOfferingAnnotations relationships from objects passed in.
// Removes related items from R.ResourceServiceOfferingAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (o *Service) RemoveResourceServiceOfferingAnnotations(ctx context.Context, exec boil.ContextExecutor, related ...*ServiceOfferingAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServiceOfferingAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServiceOfferingAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServiceOfferingAnnotations[i] = o.R.ResourceServiceOfferingAnnotations[ln-1]
			}
			o.R.ResourceServiceOfferingAnnotations = o.R.ResourceServiceOfferingAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceServiceOfferingLabels adds the given related objects to the existing relationships
// of the service, optionally inserting them as new records.
// Appends related to o.R.ResourceServiceOfferingLabels.
// Sets related.R.Resource appropriately.
func (o *Service) AddResourceServiceOfferingLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceOfferingLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_offering_labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, serviceOfferingLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &serviceR{
			ResourceServiceOfferingLabels: related,
		}
	} else {
		o.R.ResourceServiceOfferingLabels = append(o.R.ResourceServiceOfferingLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceOfferingLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServiceOfferingLabels removes all previously related items of the
// service replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServiceOfferingLabels accordingly.
// Replaces o.R.ResourceServiceOfferingLabels with related.
// Sets related.R.Resource's ResourceServiceOfferingLabels accordingly.
func (o *Service) SetResourceServiceOfferingLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceOfferingLabel) error {
	query := "update \"service_offering_labels\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServiceOfferingLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServiceOfferingLabels = nil
	}
	return o.AddResourceServiceOfferingLabels(ctx, exec, insert, related...)
}

// RemoveResourceServiceOfferingLabels relationships from objects passed in.
// Removes related items from R.ResourceServiceOfferingLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (o *Service) RemoveResourceServiceOfferingLabels(ctx context.Context, exec boil.ContextExecutor, related ...*ServiceOfferingLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServiceOfferingLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServiceOfferingLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServiceOfferingLabels[i] = o.R.ResourceServiceOfferingLabels[ln-1]
			}
			o.R.ResourceServiceOfferingLabels = o.R.ResourceServiceOfferingLabels[:ln-1]
			break
		}
	}

	return nil
}

// AddServicePlans adds the given related objects to the existing relationships
// of the service, optionally inserting them as new records.
// Appends related to o.R.ServicePlans.
// Sets related.R.Service appropriately.
func (o *Service) AddServicePlans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ServiceID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_plans\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"service_id"}),
				strmangle.WhereClause("\"", "\"", 2, servicePlanPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ServiceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &serviceR{
			ServicePlans: related,
		}
	} else {
		o.R.ServicePlans = append(o.R.ServicePlans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &servicePlanR{
				Service: o,
			}
		} else {
			rel.R.Service = o
		}
	}
	return nil
}

// Services retrieves all the records using an executor.
func Services(mods ...qm.QueryMod) serviceQuery {
	mods = append(mods, qm.From("\"services\""))
	return serviceQuery{NewQuery(mods...)}
}

// FindService retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindService(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Service, error) {
	serviceObj := &Service{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"services\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, serviceObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from services")
	}

	if err = serviceObj.doAfterSelectHooks(ctx, exec); err != nil {
		return serviceObj, err
	}

	return serviceObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Service) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no services provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(serviceColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	serviceInsertCacheMut.RLock()
	cache, cached := serviceInsertCache[key]
	serviceInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			serviceAllColumns,
			serviceColumnsWithDefault,
			serviceColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(serviceType, serviceMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(serviceType, serviceMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"services\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"services\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into services")
	}

	if !cached {
		serviceInsertCacheMut.Lock()
		serviceInsertCache[key] = cache
		serviceInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Service.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Service) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	serviceUpdateCacheMut.RLock()
	cache, cached := serviceUpdateCache[key]
	serviceUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			serviceAllColumns,
			servicePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update services, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"services\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, servicePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(serviceType, serviceMapping, append(wl, servicePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update services row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for services")
	}

	if !cached {
		serviceUpdateCacheMut.Lock()
		serviceUpdateCache[key] = cache
		serviceUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q serviceQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for services")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for services")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ServiceSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"services\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, servicePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in service slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all service")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Service) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no services provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(serviceColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	serviceUpsertCacheMut.RLock()
	cache, cached := serviceUpsertCache[key]
	serviceUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			serviceAllColumns,
			serviceColumnsWithDefault,
			serviceColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			serviceAllColumns,
			servicePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert services, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(servicePrimaryKeyColumns))
			copy(conflict, servicePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"services\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(serviceType, serviceMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(serviceType, serviceMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert services")
	}

	if !cached {
		serviceUpsertCacheMut.Lock()
		serviceUpsertCache[key] = cache
		serviceUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Service record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Service) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Service provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), servicePrimaryKeyMapping)
	sql := "DELETE FROM \"services\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from services")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for services")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q serviceQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no serviceQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from services")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for services")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ServiceSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(serviceBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"services\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, servicePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from service slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for services")
	}

	if len(serviceAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Service) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindService(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ServiceSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ServiceSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"services\".* FROM \"services\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, servicePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ServiceSlice")
	}

	*o = slice

	return nil
}

// ServiceExists checks if the Service row exists.
func ServiceExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"services\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if services exists")
	}

	return exists, nil
}
