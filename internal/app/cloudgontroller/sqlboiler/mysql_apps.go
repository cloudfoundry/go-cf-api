// +build mysql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// App is an object representing the database table.
type App struct {
	ID                            int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                          string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt                     time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                     null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	SpaceGUID                     null.String `boil:"space_guid" json:"space_guid,omitempty" toml:"space_guid" yaml:"space_guid,omitempty"`
	Name                          null.String `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	DropletGUID                   null.String `boil:"droplet_guid" json:"droplet_guid,omitempty" toml:"droplet_guid" yaml:"droplet_guid,omitempty"`
	DesiredState                  null.String `boil:"desired_state" json:"desired_state,omitempty" toml:"desired_state" yaml:"desired_state,omitempty"`
	EncryptedEnvironmentVariables null.String `boil:"encrypted_environment_variables" json:"encrypted_environment_variables,omitempty" toml:"encrypted_environment_variables" yaml:"encrypted_environment_variables,omitempty"`
	Salt                          null.String `boil:"salt" json:"salt,omitempty" toml:"salt" yaml:"salt,omitempty"`
	MaxTaskSequenceID             null.Int    `boil:"max_task_sequence_id" json:"max_task_sequence_id,omitempty" toml:"max_task_sequence_id" yaml:"max_task_sequence_id,omitempty"`
	BuildpackCacheSha256Checksum  null.String `boil:"buildpack_cache_sha256_checksum" json:"buildpack_cache_sha256_checksum,omitempty" toml:"buildpack_cache_sha256_checksum" yaml:"buildpack_cache_sha256_checksum,omitempty"`
	EnableSSH                     null.Bool   `boil:"enable_ssh" json:"enable_ssh,omitempty" toml:"enable_ssh" yaml:"enable_ssh,omitempty"`
	EncryptionKeyLabel            null.String `boil:"encryption_key_label" json:"encryption_key_label,omitempty" toml:"encryption_key_label" yaml:"encryption_key_label,omitempty"`
	EncryptionIterations          int         `boil:"encryption_iterations" json:"encryption_iterations" toml:"encryption_iterations" yaml:"encryption_iterations"`
	RevisionsEnabled              null.Bool   `boil:"revisions_enabled" json:"revisions_enabled,omitempty" toml:"revisions_enabled" yaml:"revisions_enabled,omitempty"`

	R *appR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L appL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AppColumns = struct {
	ID                            string
	GUID                          string
	CreatedAt                     string
	UpdatedAt                     string
	SpaceGUID                     string
	Name                          string
	DropletGUID                   string
	DesiredState                  string
	EncryptedEnvironmentVariables string
	Salt                          string
	MaxTaskSequenceID             string
	BuildpackCacheSha256Checksum  string
	EnableSSH                     string
	EncryptionKeyLabel            string
	EncryptionIterations          string
	RevisionsEnabled              string
}{
	ID:                            "id",
	GUID:                          "guid",
	CreatedAt:                     "created_at",
	UpdatedAt:                     "updated_at",
	SpaceGUID:                     "space_guid",
	Name:                          "name",
	DropletGUID:                   "droplet_guid",
	DesiredState:                  "desired_state",
	EncryptedEnvironmentVariables: "encrypted_environment_variables",
	Salt:                          "salt",
	MaxTaskSequenceID:             "max_task_sequence_id",
	BuildpackCacheSha256Checksum:  "buildpack_cache_sha256_checksum",
	EnableSSH:                     "enable_ssh",
	EncryptionKeyLabel:            "encryption_key_label",
	EncryptionIterations:          "encryption_iterations",
	RevisionsEnabled:              "revisions_enabled",
}

var AppTableColumns = struct {
	ID                            string
	GUID                          string
	CreatedAt                     string
	UpdatedAt                     string
	SpaceGUID                     string
	Name                          string
	DropletGUID                   string
	DesiredState                  string
	EncryptedEnvironmentVariables string
	Salt                          string
	MaxTaskSequenceID             string
	BuildpackCacheSha256Checksum  string
	EnableSSH                     string
	EncryptionKeyLabel            string
	EncryptionIterations          string
	RevisionsEnabled              string
}{
	ID:                            "apps.id",
	GUID:                          "apps.guid",
	CreatedAt:                     "apps.created_at",
	UpdatedAt:                     "apps.updated_at",
	SpaceGUID:                     "apps.space_guid",
	Name:                          "apps.name",
	DropletGUID:                   "apps.droplet_guid",
	DesiredState:                  "apps.desired_state",
	EncryptedEnvironmentVariables: "apps.encrypted_environment_variables",
	Salt:                          "apps.salt",
	MaxTaskSequenceID:             "apps.max_task_sequence_id",
	BuildpackCacheSha256Checksum:  "apps.buildpack_cache_sha256_checksum",
	EnableSSH:                     "apps.enable_ssh",
	EncryptionKeyLabel:            "apps.encryption_key_label",
	EncryptionIterations:          "apps.encryption_iterations",
	RevisionsEnabled:              "apps.revisions_enabled",
}

// Generated where

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var AppWhere = struct {
	ID                            whereHelperint
	GUID                          whereHelperstring
	CreatedAt                     whereHelpertime_Time
	UpdatedAt                     whereHelpernull_Time
	SpaceGUID                     whereHelpernull_String
	Name                          whereHelpernull_String
	DropletGUID                   whereHelpernull_String
	DesiredState                  whereHelpernull_String
	EncryptedEnvironmentVariables whereHelpernull_String
	Salt                          whereHelpernull_String
	MaxTaskSequenceID             whereHelpernull_Int
	BuildpackCacheSha256Checksum  whereHelpernull_String
	EnableSSH                     whereHelpernull_Bool
	EncryptionKeyLabel            whereHelpernull_String
	EncryptionIterations          whereHelperint
	RevisionsEnabled              whereHelpernull_Bool
}{
	ID:                            whereHelperint{field: "`apps`.`id`"},
	GUID:                          whereHelperstring{field: "`apps`.`guid`"},
	CreatedAt:                     whereHelpertime_Time{field: "`apps`.`created_at`"},
	UpdatedAt:                     whereHelpernull_Time{field: "`apps`.`updated_at`"},
	SpaceGUID:                     whereHelpernull_String{field: "`apps`.`space_guid`"},
	Name:                          whereHelpernull_String{field: "`apps`.`name`"},
	DropletGUID:                   whereHelpernull_String{field: "`apps`.`droplet_guid`"},
	DesiredState:                  whereHelpernull_String{field: "`apps`.`desired_state`"},
	EncryptedEnvironmentVariables: whereHelpernull_String{field: "`apps`.`encrypted_environment_variables`"},
	Salt:                          whereHelpernull_String{field: "`apps`.`salt`"},
	MaxTaskSequenceID:             whereHelpernull_Int{field: "`apps`.`max_task_sequence_id`"},
	BuildpackCacheSha256Checksum:  whereHelpernull_String{field: "`apps`.`buildpack_cache_sha256_checksum`"},
	EnableSSH:                     whereHelpernull_Bool{field: "`apps`.`enable_ssh`"},
	EncryptionKeyLabel:            whereHelpernull_String{field: "`apps`.`encryption_key_label`"},
	EncryptionIterations:          whereHelperint{field: "`apps`.`encryption_iterations`"},
	RevisionsEnabled:              whereHelpernull_Bool{field: "`apps`.`revisions_enabled`"},
}

// AppRels is where relationship names are stored.
var AppRels = struct {
	Space                  string
	ResourceAppAnnotations string
	ResourceAppLabels      string
	Builds                 string
	Deployments            string
	Droplets               string
	KpackLifecycleData     string
	Packages               string
	Processes              string
	Revisions              string
	RouteMappings          string
	ServiceBindings        string
	Sidecars               string
	Tasks                  string
}{
	Space:                  "Space",
	ResourceAppAnnotations: "ResourceAppAnnotations",
	ResourceAppLabels:      "ResourceAppLabels",
	Builds:                 "Builds",
	Deployments:            "Deployments",
	Droplets:               "Droplets",
	KpackLifecycleData:     "KpackLifecycleData",
	Packages:               "Packages",
	Processes:              "Processes",
	Revisions:              "Revisions",
	RouteMappings:          "RouteMappings",
	ServiceBindings:        "ServiceBindings",
	Sidecars:               "Sidecars",
	Tasks:                  "Tasks",
}

// appR is where relationships are stored.
type appR struct {
	Space                  *Space                   `boil:"Space" json:"Space" toml:"Space" yaml:"Space"`
	ResourceAppAnnotations AppAnnotationSlice       `boil:"ResourceAppAnnotations" json:"ResourceAppAnnotations" toml:"ResourceAppAnnotations" yaml:"ResourceAppAnnotations"`
	ResourceAppLabels      AppLabelSlice            `boil:"ResourceAppLabels" json:"ResourceAppLabels" toml:"ResourceAppLabels" yaml:"ResourceAppLabels"`
	Builds                 BuildSlice               `boil:"Builds" json:"Builds" toml:"Builds" yaml:"Builds"`
	Deployments            DeploymentSlice          `boil:"Deployments" json:"Deployments" toml:"Deployments" yaml:"Deployments"`
	Droplets               DropletSlice             `boil:"Droplets" json:"Droplets" toml:"Droplets" yaml:"Droplets"`
	KpackLifecycleData     KpackLifecycleDatumSlice `boil:"KpackLifecycleData" json:"KpackLifecycleData" toml:"KpackLifecycleData" yaml:"KpackLifecycleData"`
	Packages               PackageSlice             `boil:"Packages" json:"Packages" toml:"Packages" yaml:"Packages"`
	Processes              ProcessSlice             `boil:"Processes" json:"Processes" toml:"Processes" yaml:"Processes"`
	Revisions              RevisionSlice            `boil:"Revisions" json:"Revisions" toml:"Revisions" yaml:"Revisions"`
	RouteMappings          RouteMappingSlice        `boil:"RouteMappings" json:"RouteMappings" toml:"RouteMappings" yaml:"RouteMappings"`
	ServiceBindings        ServiceBindingSlice      `boil:"ServiceBindings" json:"ServiceBindings" toml:"ServiceBindings" yaml:"ServiceBindings"`
	Sidecars               SidecarSlice             `boil:"Sidecars" json:"Sidecars" toml:"Sidecars" yaml:"Sidecars"`
	Tasks                  TaskSlice                `boil:"Tasks" json:"Tasks" toml:"Tasks" yaml:"Tasks"`
}

// NewStruct creates a new relationship struct
func (*appR) NewStruct() *appR {
	return &appR{}
}

// appL is where Load methods for each relationship are stored.
type appL struct{}

var (
	appAllColumns            = []string{"id", "guid", "created_at", "updated_at", "space_guid", "name", "droplet_guid", "desired_state", "encrypted_environment_variables", "salt", "max_task_sequence_id", "buildpack_cache_sha256_checksum", "enable_ssh", "encryption_key_label", "encryption_iterations", "revisions_enabled"}
	appColumnsWithoutDefault = []string{"guid", "updated_at", "space_guid", "name", "droplet_guid", "encrypted_environment_variables", "salt", "buildpack_cache_sha256_checksum", "enable_ssh", "encryption_key_label"}
	appColumnsWithDefault    = []string{"id", "created_at", "desired_state", "max_task_sequence_id", "encryption_iterations", "revisions_enabled"}
	appPrimaryKeyColumns     = []string{"id"}
)

type (
	// AppSlice is an alias for a slice of pointers to App.
	// This should almost always be used instead of []App.
	AppSlice []*App

	AppQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	appType                 = reflect.TypeOf(&App{})
	appMapping              = queries.MakeStructMapping(appType)
	appPrimaryKeyMapping, _ = queries.BindMapping(appType, appMapping, appPrimaryKeyColumns)
	appInsertCacheMut       sync.RWMutex
	appInsertCache          = make(map[string]insertCache)
	appUpdateCacheMut       sync.RWMutex
	appUpdateCache          = make(map[string]updateCache)
	appUpsertCacheMut       sync.RWMutex
	appUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type AppFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*App, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (AppSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single app record from the query.
func (q AppQuery) One(ctx context.Context, exec boil.ContextExecutor) (*App, error) {
	o := &App{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for apps")
	}

	return o, nil
}

// All returns all App records from the query.
func (q AppQuery) All(ctx context.Context, exec boil.ContextExecutor) (AppSlice, error) {
	var o []*App

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to App slice")
	}

	return o, nil
}

// Count returns the count of all App records in the query.
func (q AppQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count apps rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q AppQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if apps exists")
	}

	return count > 0, nil
}

// Space pointed to by the foreign key.
func (q AppQuery) Space(o *App, mods ...qm.QueryMod) SpaceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`guid` = ?", o.SpaceGUID),
	}

	queryMods = append(queryMods, mods...)

	query := Spaces(queryMods...)
	queries.SetFrom(query.Query, "`spaces`")

	return query
}

// ResourceAppAnnotations retrieves all the app_annotation's AppAnnotations with an executor via resource_guid column.
func (q AppQuery) ResourceAppAnnotations(o *App, mods ...qm.QueryMod) AppAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`app_annotations`.`resource_guid`=?", o.GUID),
	)

	query := AppAnnotations(queryMods...)
	queries.SetFrom(query.Query, "`app_annotations`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`app_annotations`.*"})
	}

	return query
}

// ResourceAppLabels retrieves all the app_label's AppLabels with an executor via resource_guid column.
func (q AppQuery) ResourceAppLabels(o *App, mods ...qm.QueryMod) AppLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`app_labels`.`resource_guid`=?", o.GUID),
	)

	query := AppLabels(queryMods...)
	queries.SetFrom(query.Query, "`app_labels`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`app_labels`.*"})
	}

	return query
}

// Builds retrieves all the build's Builds with an executor.
func (q AppQuery) Builds(o *App, mods ...qm.QueryMod) BuildQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`builds`.`app_guid`=?", o.GUID),
	)

	query := Builds(queryMods...)
	queries.SetFrom(query.Query, "`builds`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`builds`.*"})
	}

	return query
}

// Deployments retrieves all the deployment's Deployments with an executor.
func (q AppQuery) Deployments(o *App, mods ...qm.QueryMod) DeploymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`deployments`.`app_guid`=?", o.GUID),
	)

	query := Deployments(queryMods...)
	queries.SetFrom(query.Query, "`deployments`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`deployments`.*"})
	}

	return query
}

// Droplets retrieves all the droplet's Droplets with an executor.
func (q AppQuery) Droplets(o *App, mods ...qm.QueryMod) DropletQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`droplets`.`app_guid`=?", o.GUID),
	)

	query := Droplets(queryMods...)
	queries.SetFrom(query.Query, "`droplets`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`droplets`.*"})
	}

	return query
}

// KpackLifecycleData retrieves all the kpack_lifecycle_datum's KpackLifecycleData with an executor.
func (q AppQuery) KpackLifecycleData(o *App, mods ...qm.QueryMod) KpackLifecycleDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`kpack_lifecycle_data`.`app_guid`=?", o.GUID),
	)

	query := KpackLifecycleData(queryMods...)
	queries.SetFrom(query.Query, "`kpack_lifecycle_data`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`kpack_lifecycle_data`.*"})
	}

	return query
}

// Packages retrieves all the package's Packages with an executor.
func (q AppQuery) Packages(o *App, mods ...qm.QueryMod) PackageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`packages`.`app_guid`=?", o.GUID),
	)

	query := Packages(queryMods...)
	queries.SetFrom(query.Query, "`packages`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`packages`.*"})
	}

	return query
}

// Processes retrieves all the process's Processes with an executor.
func (q AppQuery) Processes(o *App, mods ...qm.QueryMod) ProcessQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`processes`.`app_guid`=?", o.GUID),
	)

	query := Processes(queryMods...)
	queries.SetFrom(query.Query, "`processes`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`processes`.*"})
	}

	return query
}

// Revisions retrieves all the revision's Revisions with an executor.
func (q AppQuery) Revisions(o *App, mods ...qm.QueryMod) RevisionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`revisions`.`app_guid`=?", o.GUID),
	)

	query := Revisions(queryMods...)
	queries.SetFrom(query.Query, "`revisions`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`revisions`.*"})
	}

	return query
}

// RouteMappings retrieves all the route_mapping's RouteMappings with an executor.
func (q AppQuery) RouteMappings(o *App, mods ...qm.QueryMod) RouteMappingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`route_mappings`.`app_guid`=?", o.GUID),
	)

	query := RouteMappings(queryMods...)
	queries.SetFrom(query.Query, "`route_mappings`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`route_mappings`.*"})
	}

	return query
}

// ServiceBindings retrieves all the service_binding's ServiceBindings with an executor.
func (q AppQuery) ServiceBindings(o *App, mods ...qm.QueryMod) ServiceBindingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`service_bindings`.`app_guid`=?", o.GUID),
	)

	query := ServiceBindings(queryMods...)
	queries.SetFrom(query.Query, "`service_bindings`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`service_bindings`.*"})
	}

	return query
}

// Sidecars retrieves all the sidecar's Sidecars with an executor.
func (q AppQuery) Sidecars(o *App, mods ...qm.QueryMod) SidecarQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`sidecars`.`app_guid`=?", o.GUID),
	)

	query := Sidecars(queryMods...)
	queries.SetFrom(query.Query, "`sidecars`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`sidecars`.*"})
	}

	return query
}

// Tasks retrieves all the task's Tasks with an executor.
func (q AppQuery) Tasks(o *App, mods ...qm.QueryMod) TaskQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`tasks`.`app_guid`=?", o.GUID),
	)

	query := Tasks(queryMods...)
	queries.SetFrom(query.Query, "`tasks`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`tasks`.*"})
	}

	return query
}

// LoadSpace allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appL) LoadSpace(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		if !queries.IsNil(object.SpaceGUID) {
			args = append(args, object.SpaceGUID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SpaceGUID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SpaceGUID) {
				args = append(args, obj.SpaceGUID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`spaces`),
		qm.WhereIn(`spaces.guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Space")
	}

	var resultSlice []*Space
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Space")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for spaces")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for spaces")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Space = foreign
		if foreign.R == nil {
			foreign.R = &spaceR{}
		}
		foreign.R.Apps = append(foreign.R.Apps, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SpaceGUID, foreign.GUID) {
				local.R.Space = foreign
				if foreign.R == nil {
					foreign.R = &spaceR{}
				}
				foreign.R.Apps = append(foreign.R.Apps, local)
				break
			}
		}
	}

	return nil
}

// LoadResourceAppAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadResourceAppAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`app_annotations`),
		qm.WhereIn(`app_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load app_annotations")
	}

	var resultSlice []*AppAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice app_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on app_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for app_annotations")
	}

	if singular {
		object.R.ResourceAppAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &appAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceAppAnnotations = append(local.R.ResourceAppAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &appAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceAppLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadResourceAppLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`app_labels`),
		qm.WhereIn(`app_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load app_labels")
	}

	var resultSlice []*AppLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice app_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on app_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for app_labels")
	}

	if singular {
		object.R.ResourceAppLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &appLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceAppLabels = append(local.R.ResourceAppLabels, foreign)
				if foreign.R == nil {
					foreign.R = &appLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadBuilds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadBuilds(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`builds`),
		qm.WhereIn(`builds.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load builds")
	}

	var resultSlice []*Build
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice builds")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on builds")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for builds")
	}

	if singular {
		object.R.Builds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &buildR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Builds = append(local.R.Builds, foreign)
				if foreign.R == nil {
					foreign.R = &buildR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadDeployments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadDeployments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`deployments`),
		qm.WhereIn(`deployments.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load deployments")
	}

	var resultSlice []*Deployment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice deployments")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on deployments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for deployments")
	}

	if singular {
		object.R.Deployments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deploymentR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Deployments = append(local.R.Deployments, foreign)
				if foreign.R == nil {
					foreign.R = &deploymentR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadDroplets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadDroplets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`droplets`),
		qm.WhereIn(`droplets.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load droplets")
	}

	var resultSlice []*Droplet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice droplets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on droplets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for droplets")
	}

	if singular {
		object.R.Droplets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dropletR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Droplets = append(local.R.Droplets, foreign)
				if foreign.R == nil {
					foreign.R = &dropletR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadKpackLifecycleData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadKpackLifecycleData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`kpack_lifecycle_data`),
		qm.WhereIn(`kpack_lifecycle_data.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load kpack_lifecycle_data")
	}

	var resultSlice []*KpackLifecycleDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice kpack_lifecycle_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on kpack_lifecycle_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for kpack_lifecycle_data")
	}

	if singular {
		object.R.KpackLifecycleData = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &kpackLifecycleDatumR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.KpackLifecycleData = append(local.R.KpackLifecycleData, foreign)
				if foreign.R == nil {
					foreign.R = &kpackLifecycleDatumR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadPackages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadPackages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`packages`),
		qm.WhereIn(`packages.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load packages")
	}

	var resultSlice []*Package
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice packages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on packages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for packages")
	}

	if singular {
		object.R.Packages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &packageR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Packages = append(local.R.Packages, foreign)
				if foreign.R == nil {
					foreign.R = &packageR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadProcesses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadProcesses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`processes`),
		qm.WhereIn(`processes.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load processes")
	}

	var resultSlice []*Process
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice processes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on processes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for processes")
	}

	if singular {
		object.R.Processes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &processR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Processes = append(local.R.Processes, foreign)
				if foreign.R == nil {
					foreign.R = &processR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadRevisions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadRevisions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`revisions`),
		qm.WhereIn(`revisions.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load revisions")
	}

	var resultSlice []*Revision
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice revisions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on revisions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for revisions")
	}

	if singular {
		object.R.Revisions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &revisionR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.AppGUID) {
				local.R.Revisions = append(local.R.Revisions, foreign)
				if foreign.R == nil {
					foreign.R = &revisionR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadRouteMappings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadRouteMappings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`route_mappings`),
		qm.WhereIn(`route_mappings.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load route_mappings")
	}

	var resultSlice []*RouteMapping
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice route_mappings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on route_mappings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for route_mappings")
	}

	if singular {
		object.R.RouteMappings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &routeMappingR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.GUID == foreign.AppGUID {
				local.R.RouteMappings = append(local.R.RouteMappings, foreign)
				if foreign.R == nil {
					foreign.R = &routeMappingR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadServiceBindings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadServiceBindings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_bindings`),
		qm.WhereIn(`service_bindings.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_bindings")
	}

	var resultSlice []*ServiceBinding
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_bindings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_bindings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_bindings")
	}

	if singular {
		object.R.ServiceBindings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceBindingR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.GUID == foreign.AppGUID {
				local.R.ServiceBindings = append(local.R.ServiceBindings, foreign)
				if foreign.R == nil {
					foreign.R = &serviceBindingR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadSidecars allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadSidecars(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`sidecars`),
		qm.WhereIn(`sidecars.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sidecars")
	}

	var resultSlice []*Sidecar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sidecars")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sidecars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sidecars")
	}

	if singular {
		object.R.Sidecars = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &sidecarR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.GUID == foreign.AppGUID {
				local.R.Sidecars = append(local.R.Sidecars, foreign)
				if foreign.R == nil {
					foreign.R = &sidecarR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// LoadTasks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (appL) LoadTasks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApp interface{}, mods queries.Applicator) error {
	var slice []*App
	var object *App

	if singular {
		object = maybeApp.(*App)
	} else {
		slice = *maybeApp.(*[]*App)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &appR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`tasks`),
		qm.WhereIn(`tasks.app_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tasks")
	}

	var resultSlice []*Task
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tasks")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tasks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tasks")
	}

	if singular {
		object.R.Tasks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taskR{}
			}
			foreign.R.App = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.GUID == foreign.AppGUID {
				local.R.Tasks = append(local.R.Tasks, foreign)
				if foreign.R == nil {
					foreign.R = &taskR{}
				}
				foreign.R.App = local
				break
			}
		}
	}

	return nil
}

// SetSpace of the app to the related item.
// Sets o.R.Space to related.
// Adds o to related.R.Apps.
func (q AppQuery) SetSpace(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related *Space) error {
	var err error
	if insert {
		if err = Spaces().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `apps` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"space_guid"}),
		strmangle.WhereClause("`", "`", 0, appPrimaryKeyColumns),
	)
	values := []interface{}{related.GUID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SpaceGUID, related.GUID)
	if o.R == nil {
		o.R = &appR{
			Space: related,
		}
	} else {
		o.R.Space = related
	}

	if related.R == nil {
		related.R = &spaceR{
			Apps: AppSlice{o},
		}
	} else {
		related.R.Apps = append(related.R.Apps, o)
	}

	return nil
}

// RemoveSpace relationship.
// Sets o.R.Space to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (q AppQuery) RemoveSpace(o *App, ctx context.Context, exec boil.ContextExecutor, related *Space) error {
	var err error

	queries.SetScanner(&o.SpaceGUID, nil)
	if _, err = q.Update(o, ctx, exec, boil.Whitelist("space_guid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Space = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Apps {
		if queries.Equal(o.SpaceGUID, ri.SpaceGUID) {
			continue
		}

		ln := len(related.R.Apps)
		if ln > 1 && i < ln-1 {
			related.R.Apps[i] = related.R.Apps[ln-1]
		}
		related.R.Apps = related.R.Apps[:ln-1]
		break
	}
	return nil
}

// AddResourceAppAnnotations adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.ResourceAppAnnotations.
// Sets related.R.Resource appropriately.
func (q AppQuery) AddResourceAppAnnotations(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AppAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = AppAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `app_annotations` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, appAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			ResourceAppAnnotations: related,
		}
	} else {
		o.R.ResourceAppAnnotations = append(o.R.ResourceAppAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &appAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceAppAnnotations removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceAppAnnotations accordingly.
// Replaces o.R.ResourceAppAnnotations with related.
// Sets related.R.Resource's ResourceAppAnnotations accordingly.
func (q AppQuery) SetResourceAppAnnotations(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AppAnnotation) error {
	query := "update `app_annotations` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceAppAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceAppAnnotations = nil
	}
	return q.AddResourceAppAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourceAppAnnotations relationships from objects passed in.
// Removes related items from R.ResourceAppAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q AppQuery) RemoveResourceAppAnnotations(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*AppAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = AppAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceAppAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceAppAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceAppAnnotations[i] = o.R.ResourceAppAnnotations[ln-1]
			}
			o.R.ResourceAppAnnotations = o.R.ResourceAppAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceAppLabels adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.ResourceAppLabels.
// Sets related.R.Resource appropriately.
func (q AppQuery) AddResourceAppLabels(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AppLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = AppLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `app_labels` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, appLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			ResourceAppLabels: related,
		}
	} else {
		o.R.ResourceAppLabels = append(o.R.ResourceAppLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &appLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceAppLabels removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceAppLabels accordingly.
// Replaces o.R.ResourceAppLabels with related.
// Sets related.R.Resource's ResourceAppLabels accordingly.
func (q AppQuery) SetResourceAppLabels(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AppLabel) error {
	query := "update `app_labels` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceAppLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceAppLabels = nil
	}
	return q.AddResourceAppLabels(o, ctx, exec, insert, related...)
}

// RemoveResourceAppLabels relationships from objects passed in.
// Removes related items from R.ResourceAppLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q AppQuery) RemoveResourceAppLabels(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*AppLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = AppLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceAppLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceAppLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceAppLabels[i] = o.R.ResourceAppLabels[ln-1]
			}
			o.R.ResourceAppLabels = o.R.ResourceAppLabels[:ln-1]
			break
		}
	}

	return nil
}

// AddBuilds adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Builds.
// Sets related.R.App appropriately.
func (q AppQuery) AddBuilds(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Build) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Builds().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `builds` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, buildPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Builds: related,
		}
	} else {
		o.R.Builds = append(o.R.Builds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &buildR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetBuilds removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Builds accordingly.
// Replaces o.R.Builds with related.
// Sets related.R.App's Builds accordingly.
func (q AppQuery) SetBuilds(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Build) error {
	query := "update `builds` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Builds {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Builds = nil
	}
	return q.AddBuilds(o, ctx, exec, insert, related...)
}

// RemoveBuilds relationships from objects passed in.
// Removes related items from R.Builds (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveBuilds(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Build) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Builds().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Builds {
			if rel != ri {
				continue
			}

			ln := len(o.R.Builds)
			if ln > 1 && i < ln-1 {
				o.R.Builds[i] = o.R.Builds[ln-1]
			}
			o.R.Builds = o.R.Builds[:ln-1]
			break
		}
	}

	return nil
}

// AddDeployments adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Deployments.
// Sets related.R.App appropriately.
func (q AppQuery) AddDeployments(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Deployment) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Deployments().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `deployments` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, deploymentPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Deployments: related,
		}
	} else {
		o.R.Deployments = append(o.R.Deployments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deploymentR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetDeployments removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Deployments accordingly.
// Replaces o.R.Deployments with related.
// Sets related.R.App's Deployments accordingly.
func (q AppQuery) SetDeployments(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Deployment) error {
	query := "update `deployments` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Deployments {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Deployments = nil
	}
	return q.AddDeployments(o, ctx, exec, insert, related...)
}

// RemoveDeployments relationships from objects passed in.
// Removes related items from R.Deployments (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveDeployments(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Deployment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Deployments().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Deployments {
			if rel != ri {
				continue
			}

			ln := len(o.R.Deployments)
			if ln > 1 && i < ln-1 {
				o.R.Deployments[i] = o.R.Deployments[ln-1]
			}
			o.R.Deployments = o.R.Deployments[:ln-1]
			break
		}
	}

	return nil
}

// AddDroplets adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Droplets.
// Sets related.R.App appropriately.
func (q AppQuery) AddDroplets(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Droplet) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Droplets().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `droplets` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, dropletPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Droplets: related,
		}
	} else {
		o.R.Droplets = append(o.R.Droplets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dropletR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetDroplets removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Droplets accordingly.
// Replaces o.R.Droplets with related.
// Sets related.R.App's Droplets accordingly.
func (q AppQuery) SetDroplets(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Droplet) error {
	query := "update `droplets` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Droplets {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Droplets = nil
	}
	return q.AddDroplets(o, ctx, exec, insert, related...)
}

// RemoveDroplets relationships from objects passed in.
// Removes related items from R.Droplets (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveDroplets(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Droplet) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Droplets().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Droplets {
			if rel != ri {
				continue
			}

			ln := len(o.R.Droplets)
			if ln > 1 && i < ln-1 {
				o.R.Droplets[i] = o.R.Droplets[ln-1]
			}
			o.R.Droplets = o.R.Droplets[:ln-1]
			break
		}
	}

	return nil
}

// AddKpackLifecycleData adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.KpackLifecycleData.
// Sets related.R.App appropriately.
func (q AppQuery) AddKpackLifecycleData(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*KpackLifecycleDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = KpackLifecycleData().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `kpack_lifecycle_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, kpackLifecycleDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			KpackLifecycleData: related,
		}
	} else {
		o.R.KpackLifecycleData = append(o.R.KpackLifecycleData, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &kpackLifecycleDatumR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetKpackLifecycleData removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's KpackLifecycleData accordingly.
// Replaces o.R.KpackLifecycleData with related.
// Sets related.R.App's KpackLifecycleData accordingly.
func (q AppQuery) SetKpackLifecycleData(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*KpackLifecycleDatum) error {
	query := "update `kpack_lifecycle_data` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.KpackLifecycleData {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.KpackLifecycleData = nil
	}
	return q.AddKpackLifecycleData(o, ctx, exec, insert, related...)
}

// RemoveKpackLifecycleData relationships from objects passed in.
// Removes related items from R.KpackLifecycleData (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveKpackLifecycleData(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*KpackLifecycleDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = KpackLifecycleData().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.KpackLifecycleData {
			if rel != ri {
				continue
			}

			ln := len(o.R.KpackLifecycleData)
			if ln > 1 && i < ln-1 {
				o.R.KpackLifecycleData[i] = o.R.KpackLifecycleData[ln-1]
			}
			o.R.KpackLifecycleData = o.R.KpackLifecycleData[:ln-1]
			break
		}
	}

	return nil
}

// AddPackages adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Packages.
// Sets related.R.App appropriately.
func (q AppQuery) AddPackages(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Package) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Packages().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `packages` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, packagePrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Packages: related,
		}
	} else {
		o.R.Packages = append(o.R.Packages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &packageR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetPackages removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Packages accordingly.
// Replaces o.R.Packages with related.
// Sets related.R.App's Packages accordingly.
func (q AppQuery) SetPackages(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Package) error {
	query := "update `packages` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Packages {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Packages = nil
	}
	return q.AddPackages(o, ctx, exec, insert, related...)
}

// RemovePackages relationships from objects passed in.
// Removes related items from R.Packages (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemovePackages(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Package) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Packages().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Packages {
			if rel != ri {
				continue
			}

			ln := len(o.R.Packages)
			if ln > 1 && i < ln-1 {
				o.R.Packages[i] = o.R.Packages[ln-1]
			}
			o.R.Packages = o.R.Packages[:ln-1]
			break
		}
	}

	return nil
}

// AddProcesses adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Processes.
// Sets related.R.App appropriately.
func (q AppQuery) AddProcesses(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Process) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Processes().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `processes` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, processPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Processes: related,
		}
	} else {
		o.R.Processes = append(o.R.Processes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &processR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetProcesses removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Processes accordingly.
// Replaces o.R.Processes with related.
// Sets related.R.App's Processes accordingly.
func (q AppQuery) SetProcesses(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Process) error {
	query := "update `processes` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Processes {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Processes = nil
	}
	return q.AddProcesses(o, ctx, exec, insert, related...)
}

// RemoveProcesses relationships from objects passed in.
// Removes related items from R.Processes (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveProcesses(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Process) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Processes().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Processes {
			if rel != ri {
				continue
			}

			ln := len(o.R.Processes)
			if ln > 1 && i < ln-1 {
				o.R.Processes[i] = o.R.Processes[ln-1]
			}
			o.R.Processes = o.R.Processes[:ln-1]
			break
		}
	}

	return nil
}

// AddRevisions adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Revisions.
// Sets related.R.App appropriately.
func (q AppQuery) AddRevisions(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Revision) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AppGUID, o.GUID)
			if err = Revisions().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `revisions` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, revisionPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AppGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &appR{
			Revisions: related,
		}
	} else {
		o.R.Revisions = append(o.R.Revisions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &revisionR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// SetRevisions removes all previously related items of the
// app replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.App's Revisions accordingly.
// Replaces o.R.Revisions with related.
// Sets related.R.App's Revisions accordingly.
func (q AppQuery) SetRevisions(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Revision) error {
	query := "update `revisions` set `app_guid` = null where `app_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Revisions {
			queries.SetScanner(&rel.AppGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.App = nil
		}

		o.R.Revisions = nil
	}
	return q.AddRevisions(o, ctx, exec, insert, related...)
}

// RemoveRevisions relationships from objects passed in.
// Removes related items from R.Revisions (uses pointer comparison, removal does not keep order)
// Sets related.R.App.
func (q AppQuery) RemoveRevisions(o *App, ctx context.Context, exec boil.ContextExecutor, related ...*Revision) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AppGUID, nil)
		if rel.R != nil {
			rel.R.App = nil
		}
		if _, err = Revisions().Update(rel, ctx, exec, boil.Whitelist("app_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Revisions {
			if rel != ri {
				continue
			}

			ln := len(o.R.Revisions)
			if ln > 1 && i < ln-1 {
				o.R.Revisions[i] = o.R.Revisions[ln-1]
			}
			o.R.Revisions = o.R.Revisions[:ln-1]
			break
		}
	}

	return nil
}

// AddRouteMappings adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.RouteMappings.
// Sets related.R.App appropriately.
func (q AppQuery) AddRouteMappings(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RouteMapping) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AppGUID = o.GUID
			if err = RouteMappings().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `route_mappings` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, routeMappingPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AppGUID = o.GUID
		}
	}

	if o.R == nil {
		o.R = &appR{
			RouteMappings: related,
		}
	} else {
		o.R.RouteMappings = append(o.R.RouteMappings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &routeMappingR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// AddServiceBindings adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.ServiceBindings.
// Sets related.R.App appropriately.
func (q AppQuery) AddServiceBindings(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceBinding) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AppGUID = o.GUID
			if err = ServiceBindings().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `service_bindings` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, serviceBindingPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AppGUID = o.GUID
		}
	}

	if o.R == nil {
		o.R = &appR{
			ServiceBindings: related,
		}
	} else {
		o.R.ServiceBindings = append(o.R.ServiceBindings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceBindingR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// AddSidecars adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Sidecars.
// Sets related.R.App appropriately.
func (q AppQuery) AddSidecars(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Sidecar) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AppGUID = o.GUID
			if err = Sidecars().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `sidecars` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, sidecarPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AppGUID = o.GUID
		}
	}

	if o.R == nil {
		o.R = &appR{
			Sidecars: related,
		}
	} else {
		o.R.Sidecars = append(o.R.Sidecars, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &sidecarR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// AddTasks adds the given related objects to the existing relationships
// of the app, optionally inserting them as new records.
// Appends related to o.R.Tasks.
// Sets related.R.App appropriately.
func (q AppQuery) AddTasks(o *App, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Task) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AppGUID = o.GUID
			if err = Tasks().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `tasks` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
				strmangle.WhereClause("`", "`", 0, taskPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AppGUID = o.GUID
		}
	}

	if o.R == nil {
		o.R = &appR{
			Tasks: related,
		}
	} else {
		o.R.Tasks = append(o.R.Tasks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taskR{
				App: o,
			}
		} else {
			rel.R.App = o
		}
	}
	return nil
}

// Apps retrieves all the records using an executor.
func Apps(mods ...qm.QueryMod) AppQuery {
	mods = append(mods, qm.From("`apps`"))
	return AppQuery{NewQuery(mods...)}
}

type AppFinder interface {
	FindApp(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*App, error)
}

// FindApp retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindApp(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*App, error) {
	appObj := &App{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `apps` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, appObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from apps")
	}

	return appObj, nil
}

type AppInserter interface {
	Insert(o *App, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q AppQuery) Insert(o *App, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no apps provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(appColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	appInsertCacheMut.RLock()
	cache, cached := appInsertCache[key]
	appInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			appAllColumns,
			appColumnsWithDefault,
			appColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(appType, appMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(appType, appMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `apps` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `apps` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `apps` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, appPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into apps")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == appMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for apps")
	}

CacheNoHooks:
	if !cached {
		appInsertCacheMut.Lock()
		appInsertCache[key] = cache
		appInsertCacheMut.Unlock()
	}

	return nil
}

type AppUpdater interface {
	Update(o *App, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o AppSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the App.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q AppQuery) Update(o *App, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	appUpdateCacheMut.RLock()
	cache, cached := appUpdateCache[key]
	appUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			appAllColumns,
			appPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update apps, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `apps` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, appPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(appType, appMapping, append(wl, appPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update apps row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for apps")
	}

	if !cached {
		appUpdateCacheMut.Lock()
		appUpdateCache[key] = cache
		appUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q AppQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for apps")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for apps")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q AppQuery) UpdateAllSlice(o AppSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `apps` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, appPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in app slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all app")
	}
	return rowsAff, nil
}

type AppDeleter interface {
	Delete(o *App, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o AppSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single App record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q AppQuery) Delete(o *App, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no App provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), appPrimaryKeyMapping)
	sql := "DELETE FROM `apps` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from apps")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for apps")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q AppQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no appQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from apps")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for apps")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q AppQuery) DeleteAllSlice(o AppSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `apps` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, appPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from app slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for apps")
	}

	return rowsAff, nil
}

type AppReloader interface {
	Reload(o *App, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *AppSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q AppQuery) Reload(o *App, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindApp(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q AppQuery) ReloadAll(o *AppSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AppSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `apps`.* FROM `apps` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, appPrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AppSlice")
	}

	*o = slice

	return nil
}

// AppExists checks if the App row exists.
func AppExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `apps` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if apps exists")
	}

	return exists, nil
}

var mySQLAppUniqueColumns = []string{
	"id",
	"guid",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *App) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no apps provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(appColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLAppUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	appUpsertCacheMut.RLock()
	cache, cached := appUpsertCache[key]
	appUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			appAllColumns,
			appColumnsWithDefault,
			appColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			appAllColumns,
			appPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert apps, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`apps`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `apps` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(appType, appMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(appType, appMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for apps")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == appMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(appType, appMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for apps")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for apps")
	}

CacheNoHooks:
	if !cached {
		appUpsertCacheMut.Lock()
		appUpsertCache[key] = cache
		appUpsertCacheMut.Unlock()
	}

	return nil
}
