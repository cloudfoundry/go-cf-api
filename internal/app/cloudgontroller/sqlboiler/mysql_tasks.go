// +build mysql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Task is an object representing the database table.
type Task struct {
	ID                            int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                          string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt                     time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                     null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Name                          string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Command                       string      `boil:"command" json:"command" toml:"command" yaml:"command"`
	State                         string      `boil:"state" json:"state" toml:"state" yaml:"state"`
	MemoryInMB                    null.Int    `boil:"memory_in_mb" json:"memory_in_mb,omitempty" toml:"memory_in_mb" yaml:"memory_in_mb,omitempty"`
	EncryptedEnvironmentVariables null.String `boil:"encrypted_environment_variables" json:"encrypted_environment_variables,omitempty" toml:"encrypted_environment_variables" yaml:"encrypted_environment_variables,omitempty"`
	Salt                          null.String `boil:"salt" json:"salt,omitempty" toml:"salt" yaml:"salt,omitempty"`
	FailureReason                 null.String `boil:"failure_reason" json:"failure_reason,omitempty" toml:"failure_reason" yaml:"failure_reason,omitempty"`
	AppGUID                       string      `boil:"app_guid" json:"app_guid" toml:"app_guid" yaml:"app_guid"`
	DropletGUID                   string      `boil:"droplet_guid" json:"droplet_guid" toml:"droplet_guid" yaml:"droplet_guid"`
	SequenceID                    null.Int    `boil:"sequence_id" json:"sequence_id,omitempty" toml:"sequence_id" yaml:"sequence_id,omitempty"`
	DiskInMB                      null.Int    `boil:"disk_in_mb" json:"disk_in_mb,omitempty" toml:"disk_in_mb" yaml:"disk_in_mb,omitempty"`
	EncryptionKeyLabel            null.String `boil:"encryption_key_label" json:"encryption_key_label,omitempty" toml:"encryption_key_label" yaml:"encryption_key_label,omitempty"`
	EncryptionIterations          int         `boil:"encryption_iterations" json:"encryption_iterations" toml:"encryption_iterations" yaml:"encryption_iterations"`

	R *taskR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L taskL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TaskColumns = struct {
	ID                            string
	GUID                          string
	CreatedAt                     string
	UpdatedAt                     string
	Name                          string
	Command                       string
	State                         string
	MemoryInMB                    string
	EncryptedEnvironmentVariables string
	Salt                          string
	FailureReason                 string
	AppGUID                       string
	DropletGUID                   string
	SequenceID                    string
	DiskInMB                      string
	EncryptionKeyLabel            string
	EncryptionIterations          string
}{
	ID:                            "id",
	GUID:                          "guid",
	CreatedAt:                     "created_at",
	UpdatedAt:                     "updated_at",
	Name:                          "name",
	Command:                       "command",
	State:                         "state",
	MemoryInMB:                    "memory_in_mb",
	EncryptedEnvironmentVariables: "encrypted_environment_variables",
	Salt:                          "salt",
	FailureReason:                 "failure_reason",
	AppGUID:                       "app_guid",
	DropletGUID:                   "droplet_guid",
	SequenceID:                    "sequence_id",
	DiskInMB:                      "disk_in_mb",
	EncryptionKeyLabel:            "encryption_key_label",
	EncryptionIterations:          "encryption_iterations",
}

var TaskTableColumns = struct {
	ID                            string
	GUID                          string
	CreatedAt                     string
	UpdatedAt                     string
	Name                          string
	Command                       string
	State                         string
	MemoryInMB                    string
	EncryptedEnvironmentVariables string
	Salt                          string
	FailureReason                 string
	AppGUID                       string
	DropletGUID                   string
	SequenceID                    string
	DiskInMB                      string
	EncryptionKeyLabel            string
	EncryptionIterations          string
}{
	ID:                            "tasks.id",
	GUID:                          "tasks.guid",
	CreatedAt:                     "tasks.created_at",
	UpdatedAt:                     "tasks.updated_at",
	Name:                          "tasks.name",
	Command:                       "tasks.command",
	State:                         "tasks.state",
	MemoryInMB:                    "tasks.memory_in_mb",
	EncryptedEnvironmentVariables: "tasks.encrypted_environment_variables",
	Salt:                          "tasks.salt",
	FailureReason:                 "tasks.failure_reason",
	AppGUID:                       "tasks.app_guid",
	DropletGUID:                   "tasks.droplet_guid",
	SequenceID:                    "tasks.sequence_id",
	DiskInMB:                      "tasks.disk_in_mb",
	EncryptionKeyLabel:            "tasks.encryption_key_label",
	EncryptionIterations:          "tasks.encryption_iterations",
}

// Generated where

var TaskWhere = struct {
	ID                            whereHelperint
	GUID                          whereHelperstring
	CreatedAt                     whereHelpertime_Time
	UpdatedAt                     whereHelpernull_Time
	Name                          whereHelperstring
	Command                       whereHelperstring
	State                         whereHelperstring
	MemoryInMB                    whereHelpernull_Int
	EncryptedEnvironmentVariables whereHelpernull_String
	Salt                          whereHelpernull_String
	FailureReason                 whereHelpernull_String
	AppGUID                       whereHelperstring
	DropletGUID                   whereHelperstring
	SequenceID                    whereHelpernull_Int
	DiskInMB                      whereHelpernull_Int
	EncryptionKeyLabel            whereHelpernull_String
	EncryptionIterations          whereHelperint
}{
	ID:                            whereHelperint{field: "`tasks`.`id`"},
	GUID:                          whereHelperstring{field: "`tasks`.`guid`"},
	CreatedAt:                     whereHelpertime_Time{field: "`tasks`.`created_at`"},
	UpdatedAt:                     whereHelpernull_Time{field: "`tasks`.`updated_at`"},
	Name:                          whereHelperstring{field: "`tasks`.`name`"},
	Command:                       whereHelperstring{field: "`tasks`.`command`"},
	State:                         whereHelperstring{field: "`tasks`.`state`"},
	MemoryInMB:                    whereHelpernull_Int{field: "`tasks`.`memory_in_mb`"},
	EncryptedEnvironmentVariables: whereHelpernull_String{field: "`tasks`.`encrypted_environment_variables`"},
	Salt:                          whereHelpernull_String{field: "`tasks`.`salt`"},
	FailureReason:                 whereHelpernull_String{field: "`tasks`.`failure_reason`"},
	AppGUID:                       whereHelperstring{field: "`tasks`.`app_guid`"},
	DropletGUID:                   whereHelperstring{field: "`tasks`.`droplet_guid`"},
	SequenceID:                    whereHelpernull_Int{field: "`tasks`.`sequence_id`"},
	DiskInMB:                      whereHelpernull_Int{field: "`tasks`.`disk_in_mb`"},
	EncryptionKeyLabel:            whereHelpernull_String{field: "`tasks`.`encryption_key_label`"},
	EncryptionIterations:          whereHelperint{field: "`tasks`.`encryption_iterations`"},
}

// TaskRels is where relationship names are stored.
var TaskRels = struct {
	App                     string
	ResourceTaskAnnotations string
	ResourceTaskLabels      string
}{
	App:                     "App",
	ResourceTaskAnnotations: "ResourceTaskAnnotations",
	ResourceTaskLabels:      "ResourceTaskLabels",
}

// taskR is where relationships are stored.
type taskR struct {
	App                     *App                `boil:"App" json:"App" toml:"App" yaml:"App"`
	ResourceTaskAnnotations TaskAnnotationSlice `boil:"ResourceTaskAnnotations" json:"ResourceTaskAnnotations" toml:"ResourceTaskAnnotations" yaml:"ResourceTaskAnnotations"`
	ResourceTaskLabels      TaskLabelSlice      `boil:"ResourceTaskLabels" json:"ResourceTaskLabels" toml:"ResourceTaskLabels" yaml:"ResourceTaskLabels"`
}

// NewStruct creates a new relationship struct
func (*taskR) NewStruct() *taskR {
	return &taskR{}
}

// taskL is where Load methods for each relationship are stored.
type taskL struct{}

var (
	taskAllColumns            = []string{"id", "guid", "created_at", "updated_at", "name", "command", "state", "memory_in_mb", "encrypted_environment_variables", "salt", "failure_reason", "app_guid", "droplet_guid", "sequence_id", "disk_in_mb", "encryption_key_label", "encryption_iterations"}
	taskColumnsWithoutDefault = []string{"guid", "updated_at", "name", "command", "state", "memory_in_mb", "encrypted_environment_variables", "salt", "failure_reason", "app_guid", "droplet_guid", "sequence_id", "disk_in_mb", "encryption_key_label"}
	taskColumnsWithDefault    = []string{"id", "created_at", "encryption_iterations"}
	taskPrimaryKeyColumns     = []string{"id"}
)

type (
	// TaskSlice is an alias for a slice of pointers to Task.
	// This should almost always be used instead of []Task.
	TaskSlice []*Task

	taskQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	taskType                 = reflect.TypeOf(&Task{})
	taskMapping              = queries.MakeStructMapping(taskType)
	taskPrimaryKeyMapping, _ = queries.BindMapping(taskType, taskMapping, taskPrimaryKeyColumns)
	taskInsertCacheMut       sync.RWMutex
	taskInsertCache          = make(map[string]insertCache)
	taskUpdateCacheMut       sync.RWMutex
	taskUpdateCache          = make(map[string]updateCache)
	taskUpsertCacheMut       sync.RWMutex
	taskUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type TaskFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*Task, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (TaskSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single task record from the query.
func (q taskQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Task, error) {
	o := &Task{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for tasks")
	}

	return o, nil
}

// All returns all Task records from the query.
func (q taskQuery) All(ctx context.Context, exec boil.ContextExecutor) (TaskSlice, error) {
	var o []*Task

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Task slice")
	}

	return o, nil
}

// Count returns the count of all Task records in the query.
func (q taskQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count tasks rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q taskQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if tasks exists")
	}

	return count > 0, nil
}

// App pointed to by the foreign key.
func (q taskQuery) App(o *Task, mods ...qm.QueryMod) appQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`guid` = ?", o.AppGUID),
	}

	queryMods = append(queryMods, mods...)

	query := Apps(queryMods...)
	queries.SetFrom(query.Query, "`apps`")

	return query
}

// ResourceTaskAnnotations retrieves all the task_annotation's TaskAnnotations with an executor via resource_guid column.
func (q taskQuery) ResourceTaskAnnotations(o *Task, mods ...qm.QueryMod) taskAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`task_annotations`.`resource_guid`=?", o.GUID),
	)

	query := TaskAnnotations(queryMods...)
	queries.SetFrom(query.Query, "`task_annotations`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`task_annotations`.*"})
	}

	return query
}

// ResourceTaskLabels retrieves all the task_label's TaskLabels with an executor via resource_guid column.
func (q taskQuery) ResourceTaskLabels(o *Task, mods ...qm.QueryMod) taskLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`task_labels`.`resource_guid`=?", o.GUID),
	)

	query := TaskLabels(queryMods...)
	queries.SetFrom(query.Query, "`task_labels`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`task_labels`.*"})
	}

	return query
}

// LoadApp allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (taskL) LoadApp(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTask interface{}, mods queries.Applicator) error {
	var slice []*Task
	var object *Task

	if singular {
		object = maybeTask.(*Task)
	} else {
		slice = *maybeTask.(*[]*Task)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &taskR{}
		}
		args = append(args, object.AppGUID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &taskR{}
			}

			for _, a := range args {
				if a == obj.AppGUID {
					continue Outer
				}
			}

			args = append(args, obj.AppGUID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`apps`),
		qm.WhereIn(`apps.guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load App")
	}

	var resultSlice []*App
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice App")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for apps")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for apps")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.App = foreign
		if foreign.R == nil {
			foreign.R = &appR{}
		}
		foreign.R.Tasks = append(foreign.R.Tasks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AppGUID == foreign.GUID {
				local.R.App = foreign
				if foreign.R == nil {
					foreign.R = &appR{}
				}
				foreign.R.Tasks = append(foreign.R.Tasks, local)
				break
			}
		}
	}

	return nil
}

// LoadResourceTaskAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (taskL) LoadResourceTaskAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTask interface{}, mods queries.Applicator) error {
	var slice []*Task
	var object *Task

	if singular {
		object = maybeTask.(*Task)
	} else {
		slice = *maybeTask.(*[]*Task)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &taskR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &taskR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`task_annotations`),
		qm.WhereIn(`task_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load task_annotations")
	}

	var resultSlice []*TaskAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice task_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on task_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for task_annotations")
	}

	if singular {
		object.R.ResourceTaskAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taskAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceTaskAnnotations = append(local.R.ResourceTaskAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &taskAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceTaskLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (taskL) LoadResourceTaskLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeTask interface{}, mods queries.Applicator) error {
	var slice []*Task
	var object *Task

	if singular {
		object = maybeTask.(*Task)
	} else {
		slice = *maybeTask.(*[]*Task)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &taskR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &taskR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`task_labels`),
		qm.WhereIn(`task_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load task_labels")
	}

	var resultSlice []*TaskLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice task_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on task_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for task_labels")
	}

	if singular {
		object.R.ResourceTaskLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taskLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceTaskLabels = append(local.R.ResourceTaskLabels, foreign)
				if foreign.R == nil {
					foreign.R = &taskLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// SetApp of the task to the related item.
// Sets o.R.App to related.
// Adds o to related.R.Tasks.
func (q taskQuery) SetApp(o *Task, ctx context.Context, exec boil.ContextExecutor, insert bool, related *App) error {
	var err error
	if insert {
		if err = Apps().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `tasks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
		strmangle.WhereClause("`", "`", 0, taskPrimaryKeyColumns),
	)
	values := []interface{}{related.GUID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AppGUID = related.GUID
	if o.R == nil {
		o.R = &taskR{
			App: related,
		}
	} else {
		o.R.App = related
	}

	if related.R == nil {
		related.R = &appR{
			Tasks: TaskSlice{o},
		}
	} else {
		related.R.Tasks = append(related.R.Tasks, o)
	}

	return nil
}

// AddResourceTaskAnnotations adds the given related objects to the existing relationships
// of the task, optionally inserting them as new records.
// Appends related to o.R.ResourceTaskAnnotations.
// Sets related.R.Resource appropriately.
func (q taskQuery) AddResourceTaskAnnotations(o *Task, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaskAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = TaskAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `task_annotations` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, taskAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &taskR{
			ResourceTaskAnnotations: related,
		}
	} else {
		o.R.ResourceTaskAnnotations = append(o.R.ResourceTaskAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taskAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceTaskAnnotations removes all previously related items of the
// task replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceTaskAnnotations accordingly.
// Replaces o.R.ResourceTaskAnnotations with related.
// Sets related.R.Resource's ResourceTaskAnnotations accordingly.
func (q taskQuery) SetResourceTaskAnnotations(o *Task, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaskAnnotation) error {
	query := "update `task_annotations` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceTaskAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceTaskAnnotations = nil
	}
	return q.AddResourceTaskAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourceTaskAnnotations relationships from objects passed in.
// Removes related items from R.ResourceTaskAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q taskQuery) RemoveResourceTaskAnnotations(o *Task, ctx context.Context, exec boil.ContextExecutor, related ...*TaskAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = TaskAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceTaskAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceTaskAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceTaskAnnotations[i] = o.R.ResourceTaskAnnotations[ln-1]
			}
			o.R.ResourceTaskAnnotations = o.R.ResourceTaskAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceTaskLabels adds the given related objects to the existing relationships
// of the task, optionally inserting them as new records.
// Appends related to o.R.ResourceTaskLabels.
// Sets related.R.Resource appropriately.
func (q taskQuery) AddResourceTaskLabels(o *Task, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaskLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = TaskLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `task_labels` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, taskLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &taskR{
			ResourceTaskLabels: related,
		}
	} else {
		o.R.ResourceTaskLabels = append(o.R.ResourceTaskLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taskLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceTaskLabels removes all previously related items of the
// task replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceTaskLabels accordingly.
// Replaces o.R.ResourceTaskLabels with related.
// Sets related.R.Resource's ResourceTaskLabels accordingly.
func (q taskQuery) SetResourceTaskLabels(o *Task, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*TaskLabel) error {
	query := "update `task_labels` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceTaskLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceTaskLabels = nil
	}
	return q.AddResourceTaskLabels(o, ctx, exec, insert, related...)
}

// RemoveResourceTaskLabels relationships from objects passed in.
// Removes related items from R.ResourceTaskLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q taskQuery) RemoveResourceTaskLabels(o *Task, ctx context.Context, exec boil.ContextExecutor, related ...*TaskLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = TaskLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceTaskLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceTaskLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceTaskLabels[i] = o.R.ResourceTaskLabels[ln-1]
			}
			o.R.ResourceTaskLabels = o.R.ResourceTaskLabels[:ln-1]
			break
		}
	}

	return nil
}

// Tasks retrieves all the records using an executor.
func Tasks(mods ...qm.QueryMod) taskQuery {
	mods = append(mods, qm.From("`tasks`"))
	return taskQuery{NewQuery(mods...)}
}

type TaskFinder interface {
	FindTask(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Task, error)
}

// FindTask retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTask(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Task, error) {
	taskObj := &Task{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `tasks` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, taskObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from tasks")
	}

	return taskObj, nil
}

type TaskInserter interface {
	Insert(o *Task, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q taskQuery) Insert(o *Task, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no tasks provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(taskColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	taskInsertCacheMut.RLock()
	cache, cached := taskInsertCache[key]
	taskInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			taskAllColumns,
			taskColumnsWithDefault,
			taskColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(taskType, taskMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(taskType, taskMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `tasks` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `tasks` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `tasks` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, taskPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into tasks")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == taskMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for tasks")
	}

CacheNoHooks:
	if !cached {
		taskInsertCacheMut.Lock()
		taskInsertCache[key] = cache
		taskInsertCacheMut.Unlock()
	}

	return nil
}

type TaskUpdater interface {
	Update(o *Task, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o TaskSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the Task.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q taskQuery) Update(o *Task, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	taskUpdateCacheMut.RLock()
	cache, cached := taskUpdateCache[key]
	taskUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			taskAllColumns,
			taskPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update tasks, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `tasks` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, taskPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(taskType, taskMapping, append(wl, taskPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update tasks row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for tasks")
	}

	if !cached {
		taskUpdateCacheMut.Lock()
		taskUpdateCache[key] = cache
		taskUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q taskQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for tasks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for tasks")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q taskQuery) UpdateAllSlice(o TaskSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), taskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `tasks` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, taskPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in task slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all task")
	}
	return rowsAff, nil
}

type TaskDeleter interface {
	Delete(o *Task, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o TaskSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single Task record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q taskQuery) Delete(o *Task, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Task provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), taskPrimaryKeyMapping)
	sql := "DELETE FROM `tasks` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from tasks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for tasks")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q taskQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no taskQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from tasks")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for tasks")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q taskQuery) DeleteAllSlice(o TaskSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), taskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `tasks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, taskPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from task slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for tasks")
	}

	return rowsAff, nil
}

type TaskReloader interface {
	Reload(o *Task, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *TaskSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q taskQuery) Reload(o *Task, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTask(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q taskQuery) ReloadAll(o *TaskSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TaskSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), taskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `tasks`.* FROM `tasks` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, taskPrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in TaskSlice")
	}

	*o = slice

	return nil
}

// TaskExists checks if the Task row exists.
func TaskExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `tasks` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if tasks exists")
	}

	return exists, nil
}

var mySQLTaskUniqueColumns = []string{
	"id",
	"guid",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Task) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no tasks provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(taskColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLTaskUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	taskUpsertCacheMut.RLock()
	cache, cached := taskUpsertCache[key]
	taskUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			taskAllColumns,
			taskColumnsWithDefault,
			taskColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			taskAllColumns,
			taskPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert tasks, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`tasks`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `tasks` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(taskType, taskMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(taskType, taskMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for tasks")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == taskMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(taskType, taskMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for tasks")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for tasks")
	}

CacheNoHooks:
	if !cached {
		taskUpsertCacheMut.Lock()
		taskUpsertCache[key] = cache
		taskUpsertCacheMut.Unlock()
	}

	return nil
}
