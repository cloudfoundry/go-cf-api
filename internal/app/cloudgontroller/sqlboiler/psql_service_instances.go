//go:generate mockgen -source=$GOFILE -destination=mocks/service_instances.go
// +build psql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// ServiceInstance is an object representing the database table.
type ServiceInstance struct {
	ID                   int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                 string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt            time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt            null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Name                 string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Credentials          null.String `boil:"credentials" json:"credentials,omitempty" toml:"credentials" yaml:"credentials,omitempty"`
	GatewayName          null.String `boil:"gateway_name" json:"gateway_name,omitempty" toml:"gateway_name" yaml:"gateway_name,omitempty"`
	GatewayData          null.String `boil:"gateway_data" json:"gateway_data,omitempty" toml:"gateway_data" yaml:"gateway_data,omitempty"`
	SpaceID              int         `boil:"space_id" json:"space_id" toml:"space_id" yaml:"space_id"`
	ServicePlanID        null.Int    `boil:"service_plan_id" json:"service_plan_id,omitempty" toml:"service_plan_id" yaml:"service_plan_id,omitempty"`
	Salt                 null.String `boil:"salt" json:"salt,omitempty" toml:"salt" yaml:"salt,omitempty"`
	DashboardURL         null.String `boil:"dashboard_url" json:"dashboard_url,omitempty" toml:"dashboard_url" yaml:"dashboard_url,omitempty"`
	IsGatewayService     bool        `boil:"is_gateway_service" json:"is_gateway_service" toml:"is_gateway_service" yaml:"is_gateway_service"`
	SyslogDrainURL       null.String `boil:"syslog_drain_url" json:"syslog_drain_url,omitempty" toml:"syslog_drain_url" yaml:"syslog_drain_url,omitempty"`
	Tags                 null.String `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	RouteServiceURL      null.String `boil:"route_service_url" json:"route_service_url,omitempty" toml:"route_service_url" yaml:"route_service_url,omitempty"`
	EncryptionKeyLabel   null.String `boil:"encryption_key_label" json:"encryption_key_label,omitempty" toml:"encryption_key_label" yaml:"encryption_key_label,omitempty"`
	EncryptionIterations int         `boil:"encryption_iterations" json:"encryption_iterations" toml:"encryption_iterations" yaml:"encryption_iterations"`
	MaintenanceInfo      null.String `boil:"maintenance_info" json:"maintenance_info,omitempty" toml:"maintenance_info" yaml:"maintenance_info,omitempty"`

	R *serviceInstanceR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L serviceInstanceL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ServiceInstanceColumns = struct {
	ID                   string
	GUID                 string
	CreatedAt            string
	UpdatedAt            string
	Name                 string
	Credentials          string
	GatewayName          string
	GatewayData          string
	SpaceID              string
	ServicePlanID        string
	Salt                 string
	DashboardURL         string
	IsGatewayService     string
	SyslogDrainURL       string
	Tags                 string
	RouteServiceURL      string
	EncryptionKeyLabel   string
	EncryptionIterations string
	MaintenanceInfo      string
}{
	ID:                   "id",
	GUID:                 "guid",
	CreatedAt:            "created_at",
	UpdatedAt:            "updated_at",
	Name:                 "name",
	Credentials:          "credentials",
	GatewayName:          "gateway_name",
	GatewayData:          "gateway_data",
	SpaceID:              "space_id",
	ServicePlanID:        "service_plan_id",
	Salt:                 "salt",
	DashboardURL:         "dashboard_url",
	IsGatewayService:     "is_gateway_service",
	SyslogDrainURL:       "syslog_drain_url",
	Tags:                 "tags",
	RouteServiceURL:      "route_service_url",
	EncryptionKeyLabel:   "encryption_key_label",
	EncryptionIterations: "encryption_iterations",
	MaintenanceInfo:      "maintenance_info",
}

var ServiceInstanceTableColumns = struct {
	ID                   string
	GUID                 string
	CreatedAt            string
	UpdatedAt            string
	Name                 string
	Credentials          string
	GatewayName          string
	GatewayData          string
	SpaceID              string
	ServicePlanID        string
	Salt                 string
	DashboardURL         string
	IsGatewayService     string
	SyslogDrainURL       string
	Tags                 string
	RouteServiceURL      string
	EncryptionKeyLabel   string
	EncryptionIterations string
	MaintenanceInfo      string
}{
	ID:                   "service_instances.id",
	GUID:                 "service_instances.guid",
	CreatedAt:            "service_instances.created_at",
	UpdatedAt:            "service_instances.updated_at",
	Name:                 "service_instances.name",
	Credentials:          "service_instances.credentials",
	GatewayName:          "service_instances.gateway_name",
	GatewayData:          "service_instances.gateway_data",
	SpaceID:              "service_instances.space_id",
	ServicePlanID:        "service_instances.service_plan_id",
	Salt:                 "service_instances.salt",
	DashboardURL:         "service_instances.dashboard_url",
	IsGatewayService:     "service_instances.is_gateway_service",
	SyslogDrainURL:       "service_instances.syslog_drain_url",
	Tags:                 "service_instances.tags",
	RouteServiceURL:      "service_instances.route_service_url",
	EncryptionKeyLabel:   "service_instances.encryption_key_label",
	EncryptionIterations: "service_instances.encryption_iterations",
	MaintenanceInfo:      "service_instances.maintenance_info",
}

// Generated where

var ServiceInstanceWhere = struct {
	ID                   whereHelperint
	GUID                 whereHelperstring
	CreatedAt            whereHelpertime_Time
	UpdatedAt            whereHelpernull_Time
	Name                 whereHelperstring
	Credentials          whereHelpernull_String
	GatewayName          whereHelpernull_String
	GatewayData          whereHelpernull_String
	SpaceID              whereHelperint
	ServicePlanID        whereHelpernull_Int
	Salt                 whereHelpernull_String
	DashboardURL         whereHelpernull_String
	IsGatewayService     whereHelperbool
	SyslogDrainURL       whereHelpernull_String
	Tags                 whereHelpernull_String
	RouteServiceURL      whereHelpernull_String
	EncryptionKeyLabel   whereHelpernull_String
	EncryptionIterations whereHelperint
	MaintenanceInfo      whereHelpernull_String
}{
	ID:                   whereHelperint{field: "\"service_instances\".\"id\""},
	GUID:                 whereHelperstring{field: "\"service_instances\".\"guid\""},
	CreatedAt:            whereHelpertime_Time{field: "\"service_instances\".\"created_at\""},
	UpdatedAt:            whereHelpernull_Time{field: "\"service_instances\".\"updated_at\""},
	Name:                 whereHelperstring{field: "\"service_instances\".\"name\""},
	Credentials:          whereHelpernull_String{field: "\"service_instances\".\"credentials\""},
	GatewayName:          whereHelpernull_String{field: "\"service_instances\".\"gateway_name\""},
	GatewayData:          whereHelpernull_String{field: "\"service_instances\".\"gateway_data\""},
	SpaceID:              whereHelperint{field: "\"service_instances\".\"space_id\""},
	ServicePlanID:        whereHelpernull_Int{field: "\"service_instances\".\"service_plan_id\""},
	Salt:                 whereHelpernull_String{field: "\"service_instances\".\"salt\""},
	DashboardURL:         whereHelpernull_String{field: "\"service_instances\".\"dashboard_url\""},
	IsGatewayService:     whereHelperbool{field: "\"service_instances\".\"is_gateway_service\""},
	SyslogDrainURL:       whereHelpernull_String{field: "\"service_instances\".\"syslog_drain_url\""},
	Tags:                 whereHelpernull_String{field: "\"service_instances\".\"tags\""},
	RouteServiceURL:      whereHelpernull_String{field: "\"service_instances\".\"route_service_url\""},
	EncryptionKeyLabel:   whereHelpernull_String{field: "\"service_instances\".\"encryption_key_label\""},
	EncryptionIterations: whereHelperint{field: "\"service_instances\".\"encryption_iterations\""},
	MaintenanceInfo:      whereHelpernull_String{field: "\"service_instances\".\"maintenance_info\""},
}

// ServiceInstanceRels is where relationship names are stored.
var ServiceInstanceRels = struct {
	Space                              string
	ServicePlan                        string
	RouteBindings                      string
	ServiceBindings                    string
	ResourceServiceInstanceAnnotations string
	ResourceServiceInstanceLabels      string
	ServiceInstanceOperations          string
	Spaces                             string
	ServiceKeys                        string
}{
	Space:                              "Space",
	ServicePlan:                        "ServicePlan",
	RouteBindings:                      "RouteBindings",
	ServiceBindings:                    "ServiceBindings",
	ResourceServiceInstanceAnnotations: "ResourceServiceInstanceAnnotations",
	ResourceServiceInstanceLabels:      "ResourceServiceInstanceLabels",
	ServiceInstanceOperations:          "ServiceInstanceOperations",
	Spaces:                             "Spaces",
	ServiceKeys:                        "ServiceKeys",
}

// serviceInstanceR is where relationships are stored.
type serviceInstanceR struct {
	Space                              *Space                         `boil:"Space" json:"Space" toml:"Space" yaml:"Space"`
	ServicePlan                        *ServicePlan                   `boil:"ServicePlan" json:"ServicePlan" toml:"ServicePlan" yaml:"ServicePlan"`
	RouteBindings                      RouteBindingSlice              `boil:"RouteBindings" json:"RouteBindings" toml:"RouteBindings" yaml:"RouteBindings"`
	ServiceBindings                    ServiceBindingSlice            `boil:"ServiceBindings" json:"ServiceBindings" toml:"ServiceBindings" yaml:"ServiceBindings"`
	ResourceServiceInstanceAnnotations ServiceInstanceAnnotationSlice `boil:"ResourceServiceInstanceAnnotations" json:"ResourceServiceInstanceAnnotations" toml:"ResourceServiceInstanceAnnotations" yaml:"ResourceServiceInstanceAnnotations"`
	ResourceServiceInstanceLabels      ServiceInstanceLabelSlice      `boil:"ResourceServiceInstanceLabels" json:"ResourceServiceInstanceLabels" toml:"ResourceServiceInstanceLabels" yaml:"ResourceServiceInstanceLabels"`
	ServiceInstanceOperations          ServiceInstanceOperationSlice  `boil:"ServiceInstanceOperations" json:"ServiceInstanceOperations" toml:"ServiceInstanceOperations" yaml:"ServiceInstanceOperations"`
	Spaces                             SpaceSlice                     `boil:"Spaces" json:"Spaces" toml:"Spaces" yaml:"Spaces"`
	ServiceKeys                        ServiceKeySlice                `boil:"ServiceKeys" json:"ServiceKeys" toml:"ServiceKeys" yaml:"ServiceKeys"`
}

// NewStruct creates a new relationship struct
func (*serviceInstanceR) NewStruct() *serviceInstanceR {
	return &serviceInstanceR{}
}

// serviceInstanceL is where Load methods for each relationship are stored.
type serviceInstanceL struct{}

var (
	serviceInstanceAllColumns            = []string{"id", "guid", "created_at", "updated_at", "name", "credentials", "gateway_name", "gateway_data", "space_id", "service_plan_id", "salt", "dashboard_url", "is_gateway_service", "syslog_drain_url", "tags", "route_service_url", "encryption_key_label", "encryption_iterations", "maintenance_info"}
	serviceInstanceColumnsWithoutDefault = []string{"guid", "updated_at", "name", "credentials", "gateway_name", "gateway_data", "space_id", "service_plan_id", "salt", "dashboard_url", "syslog_drain_url", "tags", "route_service_url", "encryption_key_label", "maintenance_info"}
	serviceInstanceColumnsWithDefault    = []string{"id", "created_at", "is_gateway_service", "encryption_iterations"}
	serviceInstancePrimaryKeyColumns     = []string{"id"}
)

type (
	// ServiceInstanceSlice is an alias for a slice of pointers to ServiceInstance.
	// This should almost always be used instead of []ServiceInstance.
	ServiceInstanceSlice []*ServiceInstance

	ServiceInstanceQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	serviceInstanceType                 = reflect.TypeOf(&ServiceInstance{})
	serviceInstanceMapping              = queries.MakeStructMapping(serviceInstanceType)
	serviceInstancePrimaryKeyMapping, _ = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, serviceInstancePrimaryKeyColumns)
	serviceInstanceInsertCacheMut       sync.RWMutex
	serviceInstanceInsertCache          = make(map[string]insertCache)
	serviceInstanceUpdateCacheMut       sync.RWMutex
	serviceInstanceUpdateCache          = make(map[string]updateCache)
	serviceInstanceUpsertCacheMut       sync.RWMutex
	serviceInstanceUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type ServiceInstanceFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*ServiceInstance, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (ServiceInstanceSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single serviceInstance record from the query.
func (q ServiceInstanceQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ServiceInstance, error) {
	o := &ServiceInstance{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for service_instances")
	}

	return o, nil
}

// All returns all ServiceInstance records from the query.
func (q ServiceInstanceQuery) All(ctx context.Context, exec boil.ContextExecutor) (ServiceInstanceSlice, error) {
	var o []*ServiceInstance

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to ServiceInstance slice")
	}

	return o, nil
}

// Count returns the count of all ServiceInstance records in the query.
func (q ServiceInstanceQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count service_instances rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q ServiceInstanceQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if service_instances exists")
	}

	return count > 0, nil
}

// Space pointed to by the foreign key.
func (q ServiceInstanceQuery) Space(o *ServiceInstance, mods ...qm.QueryMod) SpaceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SpaceID),
	}

	queryMods = append(queryMods, mods...)

	query := Spaces(queryMods...)
	queries.SetFrom(query.Query, "\"spaces\"")

	return query
}

// ServicePlan pointed to by the foreign key.
func (q ServiceInstanceQuery) ServicePlan(o *ServiceInstance, mods ...qm.QueryMod) ServicePlanQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ServicePlanID),
	}

	queryMods = append(queryMods, mods...)

	query := ServicePlans(queryMods...)
	queries.SetFrom(query.Query, "\"service_plans\"")

	return query
}

// RouteBindings retrieves all the route_binding's RouteBindings with an executor.
func (q ServiceInstanceQuery) RouteBindings(o *ServiceInstance, mods ...qm.QueryMod) RouteBindingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"route_bindings\".\"service_instance_id\"=?", o.ID),
	)

	query := RouteBindings(queryMods...)
	queries.SetFrom(query.Query, "\"route_bindings\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"route_bindings\".*"})
	}

	return query
}

// ServiceBindings retrieves all the service_binding's ServiceBindings with an executor.
func (q ServiceInstanceQuery) ServiceBindings(o *ServiceInstance, mods ...qm.QueryMod) ServiceBindingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_bindings\".\"service_instance_guid\"=?", o.GUID),
	)

	query := ServiceBindings(queryMods...)
	queries.SetFrom(query.Query, "\"service_bindings\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_bindings\".*"})
	}

	return query
}

// ResourceServiceInstanceAnnotations retrieves all the service_instance_annotation's ServiceInstanceAnnotations with an executor via resource_guid column.
func (q ServiceInstanceQuery) ResourceServiceInstanceAnnotations(o *ServiceInstance, mods ...qm.QueryMod) ServiceInstanceAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_instance_annotations\".\"resource_guid\"=?", o.GUID),
	)

	query := ServiceInstanceAnnotations(queryMods...)
	queries.SetFrom(query.Query, "\"service_instance_annotations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_instance_annotations\".*"})
	}

	return query
}

// ResourceServiceInstanceLabels retrieves all the service_instance_label's ServiceInstanceLabels with an executor via resource_guid column.
func (q ServiceInstanceQuery) ResourceServiceInstanceLabels(o *ServiceInstance, mods ...qm.QueryMod) ServiceInstanceLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_instance_labels\".\"resource_guid\"=?", o.GUID),
	)

	query := ServiceInstanceLabels(queryMods...)
	queries.SetFrom(query.Query, "\"service_instance_labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_instance_labels\".*"})
	}

	return query
}

// ServiceInstanceOperations retrieves all the service_instance_operation's ServiceInstanceOperations with an executor.
func (q ServiceInstanceQuery) ServiceInstanceOperations(o *ServiceInstance, mods ...qm.QueryMod) ServiceInstanceOperationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_instance_operations\".\"service_instance_id\"=?", o.ID),
	)

	query := ServiceInstanceOperations(queryMods...)
	queries.SetFrom(query.Query, "\"service_instance_operations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_instance_operations\".*"})
	}

	return query
}

// Spaces retrieves all the space's Spaces with an executor.
func (q ServiceInstanceQuery) Spaces(o *ServiceInstance, mods ...qm.QueryMod) SpaceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"service_instance_shares\" on \"spaces\".\"guid\" = \"service_instance_shares\".\"target_space_guid\""),
		qm.Where("\"service_instance_shares\".\"service_instance_guid\"=?", o.GUID),
	)

	query := Spaces(queryMods...)
	queries.SetFrom(query.Query, "\"spaces\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"spaces\".*"})
	}

	return query
}

// ServiceKeys retrieves all the service_key's ServiceKeys with an executor.
func (q ServiceInstanceQuery) ServiceKeys(o *ServiceInstance, mods ...qm.QueryMod) ServiceKeyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"service_keys\".\"service_instance_id\"=?", o.ID),
	)

	query := ServiceKeys(queryMods...)
	queries.SetFrom(query.Query, "\"service_keys\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"service_keys\".*"})
	}

	return query
}

// LoadSpace allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (serviceInstanceL) LoadSpace(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.SpaceID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if a == obj.SpaceID {
					continue Outer
				}
			}

			args = append(args, obj.SpaceID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`spaces`),
		qm.WhereIn(`spaces.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Space")
	}

	var resultSlice []*Space
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Space")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for spaces")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for spaces")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Space = foreign
		if foreign.R == nil {
			foreign.R = &spaceR{}
		}
		foreign.R.ServiceInstances = append(foreign.R.ServiceInstances, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SpaceID == foreign.ID {
				local.R.Space = foreign
				if foreign.R == nil {
					foreign.R = &spaceR{}
				}
				foreign.R.ServiceInstances = append(foreign.R.ServiceInstances, local)
				break
			}
		}
	}

	return nil
}

// LoadServicePlan allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (serviceInstanceL) LoadServicePlan(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		if !queries.IsNil(object.ServicePlanID) {
			args = append(args, object.ServicePlanID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ServicePlanID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ServicePlanID) {
				args = append(args, obj.ServicePlanID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_plans`),
		qm.WhereIn(`service_plans.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ServicePlan")
	}

	var resultSlice []*ServicePlan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ServicePlan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for service_plans")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_plans")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ServicePlan = foreign
		if foreign.R == nil {
			foreign.R = &servicePlanR{}
		}
		foreign.R.ServiceInstances = append(foreign.R.ServiceInstances, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ServicePlanID, foreign.ID) {
				local.R.ServicePlan = foreign
				if foreign.R == nil {
					foreign.R = &servicePlanR{}
				}
				foreign.R.ServiceInstances = append(foreign.R.ServiceInstances, local)
				break
			}
		}
	}

	return nil
}

// LoadRouteBindings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadRouteBindings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`route_bindings`),
		qm.WhereIn(`route_bindings.service_instance_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load route_bindings")
	}

	var resultSlice []*RouteBinding
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice route_bindings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on route_bindings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for route_bindings")
	}

	if singular {
		object.R.RouteBindings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &routeBindingR{}
			}
			foreign.R.ServiceInstance = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ServiceInstanceID) {
				local.R.RouteBindings = append(local.R.RouteBindings, foreign)
				if foreign.R == nil {
					foreign.R = &routeBindingR{}
				}
				foreign.R.ServiceInstance = local
				break
			}
		}
	}

	return nil
}

// LoadServiceBindings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadServiceBindings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_bindings`),
		qm.WhereIn(`service_bindings.service_instance_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_bindings")
	}

	var resultSlice []*ServiceBinding
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_bindings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_bindings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_bindings")
	}

	if singular {
		object.R.ServiceBindings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceBindingR{}
			}
			foreign.R.ServiceInstance = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.GUID == foreign.ServiceInstanceGUID {
				local.R.ServiceBindings = append(local.R.ServiceBindings, foreign)
				if foreign.R == nil {
					foreign.R = &serviceBindingR{}
				}
				foreign.R.ServiceInstance = local
				break
			}
		}
	}

	return nil
}

// LoadResourceServiceInstanceAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadResourceServiceInstanceAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_instance_annotations`),
		qm.WhereIn(`service_instance_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_instance_annotations")
	}

	var resultSlice []*ServiceInstanceAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_instance_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_instance_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_instance_annotations")
	}

	if singular {
		object.R.ResourceServiceInstanceAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceInstanceAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServiceInstanceAnnotations = append(local.R.ResourceServiceInstanceAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &serviceInstanceAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceServiceInstanceLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadResourceServiceInstanceLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_instance_labels`),
		qm.WhereIn(`service_instance_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_instance_labels")
	}

	var resultSlice []*ServiceInstanceLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_instance_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_instance_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_instance_labels")
	}

	if singular {
		object.R.ResourceServiceInstanceLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceInstanceLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServiceInstanceLabels = append(local.R.ResourceServiceInstanceLabels, foreign)
				if foreign.R == nil {
					foreign.R = &serviceInstanceLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadServiceInstanceOperations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadServiceInstanceOperations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_instance_operations`),
		qm.WhereIn(`service_instance_operations.service_instance_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_instance_operations")
	}

	var resultSlice []*ServiceInstanceOperation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_instance_operations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_instance_operations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_instance_operations")
	}

	if singular {
		object.R.ServiceInstanceOperations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceInstanceOperationR{}
			}
			foreign.R.ServiceInstance = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ServiceInstanceID) {
				local.R.ServiceInstanceOperations = append(local.R.ServiceInstanceOperations, foreign)
				if foreign.R == nil {
					foreign.R = &serviceInstanceOperationR{}
				}
				foreign.R.ServiceInstance = local
				break
			}
		}
	}

	return nil
}

// LoadSpaces allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadSpaces(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if a == obj.GUID {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"spaces\".id, \"spaces\".guid, \"spaces\".created_at, \"spaces\".updated_at, \"spaces\".name, \"spaces\".organization_id, \"spaces\".space_quota_definition_id, \"spaces\".allow_ssh, \"spaces\".isolation_segment_guid, \"a\".\"service_instance_guid\""),
		qm.From("\"spaces\""),
		qm.InnerJoin("\"service_instance_shares\" as \"a\" on \"spaces\".\"guid\" = \"a\".\"target_space_guid\""),
		qm.WhereIn("\"a\".\"service_instance_guid\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load spaces")
	}

	var resultSlice []*Space

	var localJoinCols []string
	for results.Next() {
		one := new(Space)
		var localJoinCol string

		err = results.Scan(&one.ID, &one.GUID, &one.CreatedAt, &one.UpdatedAt, &one.Name, &one.OrganizationID, &one.SpaceQuotaDefinitionID, &one.AllowSSH, &one.IsolationSegmentGUID, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for spaces")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice spaces")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on spaces")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for spaces")
	}

	if singular {
		object.R.Spaces = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &spaceR{}
			}
			foreign.R.SharedServiceInstances = append(foreign.R.SharedServiceInstances, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.GUID == localJoinCol {
				local.R.Spaces = append(local.R.Spaces, foreign)
				if foreign.R == nil {
					foreign.R = &spaceR{}
				}
				foreign.R.SharedServiceInstances = append(foreign.R.SharedServiceInstances, local)
				break
			}
		}
	}

	return nil
}

// LoadServiceKeys allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (serviceInstanceL) LoadServiceKeys(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServiceInstance interface{}, mods queries.Applicator) error {
	var slice []*ServiceInstance
	var object *ServiceInstance

	if singular {
		object = maybeServiceInstance.(*ServiceInstance)
	} else {
		slice = *maybeServiceInstance.(*[]*ServiceInstance)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &serviceInstanceR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &serviceInstanceR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_keys`),
		qm.WhereIn(`service_keys.service_instance_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_keys")
	}

	var resultSlice []*ServiceKey
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_keys")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_keys")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_keys")
	}

	if singular {
		object.R.ServiceKeys = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceKeyR{}
			}
			foreign.R.ServiceInstance = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ServiceInstanceID {
				local.R.ServiceKeys = append(local.R.ServiceKeys, foreign)
				if foreign.R == nil {
					foreign.R = &serviceKeyR{}
				}
				foreign.R.ServiceInstance = local
				break
			}
		}
	}

	return nil
}

// SetSpace of the serviceInstance to the related item.
// Sets o.R.Space to related.
// Adds o to related.R.ServiceInstances.
func (q ServiceInstanceQuery) SetSpace(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related *Space) error {
	var err error
	if insert {
		if err = Spaces().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"service_instances\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"space_id"}),
		strmangle.WhereClause("\"", "\"", 2, serviceInstancePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SpaceID = related.ID
	if o.R == nil {
		o.R = &serviceInstanceR{
			Space: related,
		}
	} else {
		o.R.Space = related
	}

	if related.R == nil {
		related.R = &spaceR{
			ServiceInstances: ServiceInstanceSlice{o},
		}
	} else {
		related.R.ServiceInstances = append(related.R.ServiceInstances, o)
	}

	return nil
}

// SetServicePlan of the serviceInstance to the related item.
// Sets o.R.ServicePlan to related.
// Adds o to related.R.ServiceInstances.
func (q ServiceInstanceQuery) SetServicePlan(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related *ServicePlan) error {
	var err error
	if insert {
		if err = ServicePlans().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"service_instances\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"service_plan_id"}),
		strmangle.WhereClause("\"", "\"", 2, serviceInstancePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ServicePlanID, related.ID)
	if o.R == nil {
		o.R = &serviceInstanceR{
			ServicePlan: related,
		}
	} else {
		o.R.ServicePlan = related
	}

	if related.R == nil {
		related.R = &servicePlanR{
			ServiceInstances: ServiceInstanceSlice{o},
		}
	} else {
		related.R.ServiceInstances = append(related.R.ServiceInstances, o)
	}

	return nil
}

// RemoveServicePlan relationship.
// Sets o.R.ServicePlan to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (q ServiceInstanceQuery) RemoveServicePlan(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related *ServicePlan) error {
	var err error

	queries.SetScanner(&o.ServicePlanID, nil)
	if _, err = q.Update(o, ctx, exec, boil.Whitelist("service_plan_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ServicePlan = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ServiceInstances {
		if queries.Equal(o.ServicePlanID, ri.ServicePlanID) {
			continue
		}

		ln := len(related.R.ServiceInstances)
		if ln > 1 && i < ln-1 {
			related.R.ServiceInstances[i] = related.R.ServiceInstances[ln-1]
		}
		related.R.ServiceInstances = related.R.ServiceInstances[:ln-1]
		break
	}
	return nil
}

// AddRouteBindings adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.RouteBindings.
// Sets related.R.ServiceInstance appropriately.
func (q ServiceInstanceQuery) AddRouteBindings(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RouteBinding) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ServiceInstanceID, o.ID)
			if err = RouteBindings().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"route_bindings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"service_instance_id"}),
				strmangle.WhereClause("\"", "\"", 2, routeBindingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ServiceInstanceID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			RouteBindings: related,
		}
	} else {
		o.R.RouteBindings = append(o.R.RouteBindings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &routeBindingR{
				ServiceInstance: o,
			}
		} else {
			rel.R.ServiceInstance = o
		}
	}
	return nil
}

// SetRouteBindings removes all previously related items of the
// service_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ServiceInstance's RouteBindings accordingly.
// Replaces o.R.RouteBindings with related.
// Sets related.R.ServiceInstance's RouteBindings accordingly.
func (q ServiceInstanceQuery) SetRouteBindings(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RouteBinding) error {
	query := "update \"route_bindings\" set \"service_instance_id\" = null where \"service_instance_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.RouteBindings {
			queries.SetScanner(&rel.ServiceInstanceID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ServiceInstance = nil
		}

		o.R.RouteBindings = nil
	}
	return q.AddRouteBindings(o, ctx, exec, insert, related...)
}

// RemoveRouteBindings relationships from objects passed in.
// Removes related items from R.RouteBindings (uses pointer comparison, removal does not keep order)
// Sets related.R.ServiceInstance.
func (q ServiceInstanceQuery) RemoveRouteBindings(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related ...*RouteBinding) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ServiceInstanceID, nil)
		if rel.R != nil {
			rel.R.ServiceInstance = nil
		}
		if _, err = RouteBindings().Update(rel, ctx, exec, boil.Whitelist("service_instance_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.RouteBindings {
			if rel != ri {
				continue
			}

			ln := len(o.R.RouteBindings)
			if ln > 1 && i < ln-1 {
				o.R.RouteBindings[i] = o.R.RouteBindings[ln-1]
			}
			o.R.RouteBindings = o.R.RouteBindings[:ln-1]
			break
		}
	}

	return nil
}

// AddServiceBindings adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.ServiceBindings.
// Sets related.R.ServiceInstance appropriately.
func (q ServiceInstanceQuery) AddServiceBindings(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceBinding) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ServiceInstanceGUID = o.GUID
			if err = ServiceBindings().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_bindings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"service_instance_guid"}),
				strmangle.WhereClause("\"", "\"", 2, serviceBindingPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ServiceInstanceGUID = o.GUID
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			ServiceBindings: related,
		}
	} else {
		o.R.ServiceBindings = append(o.R.ServiceBindings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceBindingR{
				ServiceInstance: o,
			}
		} else {
			rel.R.ServiceInstance = o
		}
	}
	return nil
}

// AddResourceServiceInstanceAnnotations adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.ResourceServiceInstanceAnnotations.
// Sets related.R.Resource appropriately.
func (q ServiceInstanceQuery) AddResourceServiceInstanceAnnotations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ServiceInstanceAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_instance_annotations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, serviceInstanceAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			ResourceServiceInstanceAnnotations: related,
		}
	} else {
		o.R.ResourceServiceInstanceAnnotations = append(o.R.ResourceServiceInstanceAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceInstanceAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServiceInstanceAnnotations removes all previously related items of the
// service_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServiceInstanceAnnotations accordingly.
// Replaces o.R.ResourceServiceInstanceAnnotations with related.
// Sets related.R.Resource's ResourceServiceInstanceAnnotations accordingly.
func (q ServiceInstanceQuery) SetResourceServiceInstanceAnnotations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceAnnotation) error {
	query := "update \"service_instance_annotations\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServiceInstanceAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServiceInstanceAnnotations = nil
	}
	return q.AddResourceServiceInstanceAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourceServiceInstanceAnnotations relationships from objects passed in.
// Removes related items from R.ResourceServiceInstanceAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q ServiceInstanceQuery) RemoveResourceServiceInstanceAnnotations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related ...*ServiceInstanceAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ServiceInstanceAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServiceInstanceAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServiceInstanceAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServiceInstanceAnnotations[i] = o.R.ResourceServiceInstanceAnnotations[ln-1]
			}
			o.R.ResourceServiceInstanceAnnotations = o.R.ResourceServiceInstanceAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceServiceInstanceLabels adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.ResourceServiceInstanceLabels.
// Sets related.R.Resource appropriately.
func (q ServiceInstanceQuery) AddResourceServiceInstanceLabels(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ServiceInstanceLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_instance_labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, serviceInstanceLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			ResourceServiceInstanceLabels: related,
		}
	} else {
		o.R.ResourceServiceInstanceLabels = append(o.R.ResourceServiceInstanceLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceInstanceLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServiceInstanceLabels removes all previously related items of the
// service_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServiceInstanceLabels accordingly.
// Replaces o.R.ResourceServiceInstanceLabels with related.
// Sets related.R.Resource's ResourceServiceInstanceLabels accordingly.
func (q ServiceInstanceQuery) SetResourceServiceInstanceLabels(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceLabel) error {
	query := "update \"service_instance_labels\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServiceInstanceLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServiceInstanceLabels = nil
	}
	return q.AddResourceServiceInstanceLabels(o, ctx, exec, insert, related...)
}

// RemoveResourceServiceInstanceLabels relationships from objects passed in.
// Removes related items from R.ResourceServiceInstanceLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q ServiceInstanceQuery) RemoveResourceServiceInstanceLabels(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related ...*ServiceInstanceLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ServiceInstanceLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServiceInstanceLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServiceInstanceLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServiceInstanceLabels[i] = o.R.ResourceServiceInstanceLabels[ln-1]
			}
			o.R.ResourceServiceInstanceLabels = o.R.ResourceServiceInstanceLabels[:ln-1]
			break
		}
	}

	return nil
}

// AddServiceInstanceOperations adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.ServiceInstanceOperations.
// Sets related.R.ServiceInstance appropriately.
func (q ServiceInstanceQuery) AddServiceInstanceOperations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceOperation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ServiceInstanceID, o.ID)
			if err = ServiceInstanceOperations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_instance_operations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"service_instance_id"}),
				strmangle.WhereClause("\"", "\"", 2, serviceInstanceOperationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ServiceInstanceID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			ServiceInstanceOperations: related,
		}
	} else {
		o.R.ServiceInstanceOperations = append(o.R.ServiceInstanceOperations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceInstanceOperationR{
				ServiceInstance: o,
			}
		} else {
			rel.R.ServiceInstance = o
		}
	}
	return nil
}

// SetServiceInstanceOperations removes all previously related items of the
// service_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ServiceInstance's ServiceInstanceOperations accordingly.
// Replaces o.R.ServiceInstanceOperations with related.
// Sets related.R.ServiceInstance's ServiceInstanceOperations accordingly.
func (q ServiceInstanceQuery) SetServiceInstanceOperations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstanceOperation) error {
	query := "update \"service_instance_operations\" set \"service_instance_id\" = null where \"service_instance_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ServiceInstanceOperations {
			queries.SetScanner(&rel.ServiceInstanceID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ServiceInstance = nil
		}

		o.R.ServiceInstanceOperations = nil
	}
	return q.AddServiceInstanceOperations(o, ctx, exec, insert, related...)
}

// RemoveServiceInstanceOperations relationships from objects passed in.
// Removes related items from R.ServiceInstanceOperations (uses pointer comparison, removal does not keep order)
// Sets related.R.ServiceInstance.
func (q ServiceInstanceQuery) RemoveServiceInstanceOperations(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related ...*ServiceInstanceOperation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ServiceInstanceID, nil)
		if rel.R != nil {
			rel.R.ServiceInstance = nil
		}
		if _, err = ServiceInstanceOperations().Update(rel, ctx, exec, boil.Whitelist("service_instance_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ServiceInstanceOperations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ServiceInstanceOperations)
			if ln > 1 && i < ln-1 {
				o.R.ServiceInstanceOperations[i] = o.R.ServiceInstanceOperations[ln-1]
			}
			o.R.ServiceInstanceOperations = o.R.ServiceInstanceOperations[:ln-1]
			break
		}
	}

	return nil
}

// AddSpaces adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.Spaces.
// Sets related.R.SharedServiceInstances appropriately.
func (q ServiceInstanceQuery) AddSpaces(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Space) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = Spaces().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"service_instance_shares\" (\"service_instance_guid\", \"target_space_guid\") values ($1, $2)"
		values := []interface{}{o.GUID, rel.GUID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &serviceInstanceR{
			Spaces: related,
		}
	} else {
		o.R.Spaces = append(o.R.Spaces, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &spaceR{
				SharedServiceInstances: ServiceInstanceSlice{o},
			}
		} else {
			rel.R.SharedServiceInstances = append(rel.R.SharedServiceInstances, o)
		}
	}
	return nil
}

// SetSpaces removes all previously related items of the
// service_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.SharedServiceInstances's Spaces accordingly.
// Replaces o.R.Spaces with related.
// Sets related.R.SharedServiceInstances's Spaces accordingly.
func (q ServiceInstanceQuery) SetSpaces(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Space) error {
	query := "delete from \"service_instance_shares\" where \"service_instance_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeSpacesFromSharedServiceInstancesSlice(o, related)
	if o.R != nil {
		o.R.Spaces = nil
	}
	return q.AddSpaces(o, ctx, exec, insert, related...)
}

// RemoveSpaces relationships from objects passed in.
// Removes related items from R.Spaces (uses pointer comparison, removal does not keep order)
// Sets related.R.SharedServiceInstances.
func (q ServiceInstanceQuery) RemoveSpaces(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, related ...*Space) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"service_instance_shares\" where \"service_instance_guid\" = $1 and \"target_space_guid\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.GUID}
	for _, rel := range related {
		values = append(values, rel.GUID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeSpacesFromSharedServiceInstancesSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Spaces {
			if rel != ri {
				continue
			}

			ln := len(o.R.Spaces)
			if ln > 1 && i < ln-1 {
				o.R.Spaces[i] = o.R.Spaces[ln-1]
			}
			o.R.Spaces = o.R.Spaces[:ln-1]
			break
		}
	}

	return nil
}

func removeSpacesFromSharedServiceInstancesSlice(o *ServiceInstance, related []*Space) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.SharedServiceInstances {
			if o.GUID != ri.GUID {
				continue
			}

			ln := len(rel.R.SharedServiceInstances)
			if ln > 1 && i < ln-1 {
				rel.R.SharedServiceInstances[i] = rel.R.SharedServiceInstances[ln-1]
			}
			rel.R.SharedServiceInstances = rel.R.SharedServiceInstances[:ln-1]
			break
		}
	}
}

// AddServiceKeys adds the given related objects to the existing relationships
// of the service_instance, optionally inserting them as new records.
// Appends related to o.R.ServiceKeys.
// Sets related.R.ServiceInstance appropriately.
func (q ServiceInstanceQuery) AddServiceKeys(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceKey) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ServiceInstanceID = o.ID
			if err = ServiceKeys().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"service_keys\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"service_instance_id"}),
				strmangle.WhereClause("\"", "\"", 2, serviceKeyPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ServiceInstanceID = o.ID
		}
	}

	if o.R == nil {
		o.R = &serviceInstanceR{
			ServiceKeys: related,
		}
	} else {
		o.R.ServiceKeys = append(o.R.ServiceKeys, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceKeyR{
				ServiceInstance: o,
			}
		} else {
			rel.R.ServiceInstance = o
		}
	}
	return nil
}

// ServiceInstances retrieves all the records using an executor.
func ServiceInstances(mods ...qm.QueryMod) ServiceInstanceQuery {
	mods = append(mods, qm.From("\"service_instances\""))
	return ServiceInstanceQuery{NewQuery(mods...)}
}

type ServiceInstanceFinder interface {
	FindServiceInstance(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*ServiceInstance, error)
}

// FindServiceInstance retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindServiceInstance(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*ServiceInstance, error) {
	serviceInstanceObj := &ServiceInstance{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"service_instances\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, serviceInstanceObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from service_instances")
	}

	return serviceInstanceObj, nil
}

type ServiceInstanceInserter interface {
	Insert(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q ServiceInstanceQuery) Insert(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no service_instances provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(serviceInstanceColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	serviceInstanceInsertCacheMut.RLock()
	cache, cached := serviceInstanceInsertCache[key]
	serviceInstanceInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			serviceInstanceAllColumns,
			serviceInstanceColumnsWithDefault,
			serviceInstanceColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"service_instances\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"service_instances\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into service_instances")
	}

	if !cached {
		serviceInstanceInsertCacheMut.Lock()
		serviceInstanceInsertCache[key] = cache
		serviceInstanceInsertCacheMut.Unlock()
	}

	return nil
}

type ServiceInstanceUpdater interface {
	Update(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the ServiceInstance.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q ServiceInstanceQuery) Update(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	serviceInstanceUpdateCacheMut.RLock()
	cache, cached := serviceInstanceUpdateCache[key]
	serviceInstanceUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			serviceInstanceAllColumns,
			serviceInstancePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update service_instances, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"service_instances\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, serviceInstancePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, append(wl, serviceInstancePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update service_instances row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for service_instances")
	}

	if !cached {
		serviceInstanceUpdateCacheMut.Lock()
		serviceInstanceUpdateCache[key] = cache
		serviceInstanceUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q ServiceInstanceQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for service_instances")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for service_instances")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q ServiceInstanceQuery) UpdateAllSlice(o ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), serviceInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"service_instances\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, serviceInstancePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in serviceInstance slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all serviceInstance")
	}
	return rowsAff, nil
}

type ServiceInstanceDeleter interface {
	Delete(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single ServiceInstance record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q ServiceInstanceQuery) Delete(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no ServiceInstance provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), serviceInstancePrimaryKeyMapping)
	sql := "DELETE FROM \"service_instances\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from service_instances")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for service_instances")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q ServiceInstanceQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no serviceInstanceQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from service_instances")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for service_instances")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q ServiceInstanceQuery) DeleteAllSlice(o ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), serviceInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"service_instances\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, serviceInstancePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from serviceInstance slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for service_instances")
	}

	return rowsAff, nil
}

type ServiceInstanceReloader interface {
	Reload(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q ServiceInstanceQuery) Reload(o *ServiceInstance, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindServiceInstance(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q ServiceInstanceQuery) ReloadAll(o *ServiceInstanceSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ServiceInstanceSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), serviceInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"service_instances\".* FROM \"service_instances\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, serviceInstancePrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ServiceInstanceSlice")
	}

	*o = slice

	return nil
}

// ServiceInstanceExists checks if the ServiceInstance row exists.
func ServiceInstanceExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"service_instances\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if service_instances exists")
	}

	return exists, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ServiceInstance) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no service_instances provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(serviceInstanceColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	serviceInstanceUpsertCacheMut.RLock()
	cache, cached := serviceInstanceUpsertCache[key]
	serviceInstanceUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			serviceInstanceAllColumns,
			serviceInstanceColumnsWithDefault,
			serviceInstanceColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			serviceInstanceAllColumns,
			serviceInstancePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert service_instances, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(serviceInstancePrimaryKeyColumns))
			copy(conflict, serviceInstancePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"service_instances\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(serviceInstanceType, serviceInstanceMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert service_instances")
	}

	if !cached {
		serviceInstanceUpsertCacheMut.Lock()
		serviceInstanceUpsertCache[key] = cache
		serviceInstanceUpsertCacheMut.Unlock()
	}

	return nil
}
