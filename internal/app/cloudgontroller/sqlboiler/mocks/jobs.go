// +build unit

// Code generated by MockGen. DO NOT EDIT.
// Source: psql_jobs.go

// Package mock_models is a generated GoMock package.
package mock_models

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	boil "github.com/volatiletech/sqlboiler/v4/boil"
	models "github.tools.sap/cloudfoundry/cloudgontroller/internal/app/cloudgontroller/sqlboiler"
)

// MockJobUpserter is a mock of JobUpserter interface.
type MockJobUpserter struct {
	ctrl     *gomock.Controller
	recorder *MockJobUpserterMockRecorder
}

// MockJobUpserterMockRecorder is the mock recorder for MockJobUpserter.
type MockJobUpserterMockRecorder struct {
	mock *MockJobUpserter
}

// NewMockJobUpserter creates a new mock instance.
func NewMockJobUpserter(ctrl *gomock.Controller) *MockJobUpserter {
	mock := &MockJobUpserter{ctrl: ctrl}
	mock.recorder = &MockJobUpserterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobUpserter) EXPECT() *MockJobUpserterMockRecorder {
	return m.recorder
}

// Upsert mocks base method.
func (m *MockJobUpserter) Upsert(o *models.Job, ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", o, ctx, exec, updateColumns, insertColumns)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert.
func (mr *MockJobUpserterMockRecorder) Upsert(o, ctx, exec, updateColumns, insertColumns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockJobUpserter)(nil).Upsert), o, ctx, exec, updateColumns, insertColumns)
}

// MockJobFinisher is a mock of JobFinisher interface.
type MockJobFinisher struct {
	ctrl     *gomock.Controller
	recorder *MockJobFinisherMockRecorder
}

// MockJobFinisherMockRecorder is the mock recorder for MockJobFinisher.
type MockJobFinisherMockRecorder struct {
	mock *MockJobFinisher
}

// NewMockJobFinisher creates a new mock instance.
func NewMockJobFinisher(ctrl *gomock.Controller) *MockJobFinisher {
	mock := &MockJobFinisher{ctrl: ctrl}
	mock.recorder = &MockJobFinisherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobFinisher) EXPECT() *MockJobFinisherMockRecorder {
	return m.recorder
}

// All mocks base method.
func (m *MockJobFinisher) All(ctx context.Context, exec boil.ContextExecutor) (models.JobSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "All", ctx, exec)
	ret0, _ := ret[0].(models.JobSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// All indicates an expected call of All.
func (mr *MockJobFinisherMockRecorder) All(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockJobFinisher)(nil).All), ctx, exec)
}

// Count mocks base method.
func (m *MockJobFinisher) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockJobFinisherMockRecorder) Count(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockJobFinisher)(nil).Count), ctx, exec)
}

// Exists mocks base method.
func (m *MockJobFinisher) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", ctx, exec)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exists indicates an expected call of Exists.
func (mr *MockJobFinisherMockRecorder) Exists(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockJobFinisher)(nil).Exists), ctx, exec)
}

// One mocks base method.
func (m *MockJobFinisher) One(ctx context.Context, exec boil.ContextExecutor) (*models.Job, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "One", ctx, exec)
	ret0, _ := ret[0].(*models.Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// One indicates an expected call of One.
func (mr *MockJobFinisherMockRecorder) One(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "One", reflect.TypeOf((*MockJobFinisher)(nil).One), ctx, exec)
}

// MockJobFinder is a mock of JobFinder interface.
type MockJobFinder struct {
	ctrl     *gomock.Controller
	recorder *MockJobFinderMockRecorder
}

// MockJobFinderMockRecorder is the mock recorder for MockJobFinder.
type MockJobFinderMockRecorder struct {
	mock *MockJobFinder
}

// NewMockJobFinder creates a new mock instance.
func NewMockJobFinder(ctrl *gomock.Controller) *MockJobFinder {
	mock := &MockJobFinder{ctrl: ctrl}
	mock.recorder = &MockJobFinderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobFinder) EXPECT() *MockJobFinderMockRecorder {
	return m.recorder
}

// FindJob mocks base method.
func (m *MockJobFinder) FindJob(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*models.Job, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, exec, iD}
	for _, a := range selectCols {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindJob", varargs...)
	ret0, _ := ret[0].(*models.Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindJob indicates an expected call of FindJob.
func (mr *MockJobFinderMockRecorder) FindJob(ctx, exec, iD interface{}, selectCols ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, exec, iD}, selectCols...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindJob", reflect.TypeOf((*MockJobFinder)(nil).FindJob), varargs...)
}

// MockJobInserter is a mock of JobInserter interface.
type MockJobInserter struct {
	ctrl     *gomock.Controller
	recorder *MockJobInserterMockRecorder
}

// MockJobInserterMockRecorder is the mock recorder for MockJobInserter.
type MockJobInserterMockRecorder struct {
	mock *MockJobInserter
}

// NewMockJobInserter creates a new mock instance.
func NewMockJobInserter(ctrl *gomock.Controller) *MockJobInserter {
	mock := &MockJobInserter{ctrl: ctrl}
	mock.recorder = &MockJobInserterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobInserter) EXPECT() *MockJobInserterMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockJobInserter) Insert(o *models.Job, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", o, ctx, exec, columns)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockJobInserterMockRecorder) Insert(o, ctx, exec, columns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockJobInserter)(nil).Insert), o, ctx, exec, columns)
}

// MockJobUpdater is a mock of JobUpdater interface.
type MockJobUpdater struct {
	ctrl     *gomock.Controller
	recorder *MockJobUpdaterMockRecorder
}

// MockJobUpdaterMockRecorder is the mock recorder for MockJobUpdater.
type MockJobUpdaterMockRecorder struct {
	mock *MockJobUpdater
}

// NewMockJobUpdater creates a new mock instance.
func NewMockJobUpdater(ctrl *gomock.Controller) *MockJobUpdater {
	mock := &MockJobUpdater{ctrl: ctrl}
	mock.recorder = &MockJobUpdaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobUpdater) EXPECT() *MockJobUpdaterMockRecorder {
	return m.recorder
}

// Update mocks base method.
func (m *MockJobUpdater) Update(o *models.Job, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", o, ctx, exec, columns)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockJobUpdaterMockRecorder) Update(o, ctx, exec, columns interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockJobUpdater)(nil).Update), o, ctx, exec, columns)
}

// UpdateAll mocks base method.
func (m *MockJobUpdater) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols models.M) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAll", ctx, exec, cols)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAll indicates an expected call of UpdateAll.
func (mr *MockJobUpdaterMockRecorder) UpdateAll(ctx, exec, cols interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAll", reflect.TypeOf((*MockJobUpdater)(nil).UpdateAll), ctx, exec, cols)
}

// UpdateAllSlice mocks base method.
func (m *MockJobUpdater) UpdateAllSlice(o models.JobSlice, ctx context.Context, exec boil.ContextExecutor, cols models.M) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateAllSlice", o, ctx, exec, cols)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateAllSlice indicates an expected call of UpdateAllSlice.
func (mr *MockJobUpdaterMockRecorder) UpdateAllSlice(o, ctx, exec, cols interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAllSlice", reflect.TypeOf((*MockJobUpdater)(nil).UpdateAllSlice), o, ctx, exec, cols)
}

// MockJobDeleter is a mock of JobDeleter interface.
type MockJobDeleter struct {
	ctrl     *gomock.Controller
	recorder *MockJobDeleterMockRecorder
}

// MockJobDeleterMockRecorder is the mock recorder for MockJobDeleter.
type MockJobDeleterMockRecorder struct {
	mock *MockJobDeleter
}

// NewMockJobDeleter creates a new mock instance.
func NewMockJobDeleter(ctrl *gomock.Controller) *MockJobDeleter {
	mock := &MockJobDeleter{ctrl: ctrl}
	mock.recorder = &MockJobDeleterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobDeleter) EXPECT() *MockJobDeleterMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockJobDeleter) Delete(o *models.Job, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", o, ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockJobDeleterMockRecorder) Delete(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockJobDeleter)(nil).Delete), o, ctx, exec)
}

// DeleteAll mocks base method.
func (m *MockJobDeleter) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAll", ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAll indicates an expected call of DeleteAll.
func (mr *MockJobDeleterMockRecorder) DeleteAll(ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAll", reflect.TypeOf((*MockJobDeleter)(nil).DeleteAll), ctx, exec)
}

// DeleteAllSlice mocks base method.
func (m *MockJobDeleter) DeleteAllSlice(o models.JobSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAllSlice", o, ctx, exec)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAllSlice indicates an expected call of DeleteAllSlice.
func (mr *MockJobDeleterMockRecorder) DeleteAllSlice(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllSlice", reflect.TypeOf((*MockJobDeleter)(nil).DeleteAllSlice), o, ctx, exec)
}

// MockJobReloader is a mock of JobReloader interface.
type MockJobReloader struct {
	ctrl     *gomock.Controller
	recorder *MockJobReloaderMockRecorder
}

// MockJobReloaderMockRecorder is the mock recorder for MockJobReloader.
type MockJobReloaderMockRecorder struct {
	mock *MockJobReloader
}

// NewMockJobReloader creates a new mock instance.
func NewMockJobReloader(ctrl *gomock.Controller) *MockJobReloader {
	mock := &MockJobReloader{ctrl: ctrl}
	mock.recorder = &MockJobReloaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobReloader) EXPECT() *MockJobReloaderMockRecorder {
	return m.recorder
}

// Reload mocks base method.
func (m *MockJobReloader) Reload(o *models.Job, ctx context.Context, exec boil.ContextExecutor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reload", o, ctx, exec)
	ret0, _ := ret[0].(error)
	return ret0
}

// Reload indicates an expected call of Reload.
func (mr *MockJobReloaderMockRecorder) Reload(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reload", reflect.TypeOf((*MockJobReloader)(nil).Reload), o, ctx, exec)
}

// ReloadAll mocks base method.
func (m *MockJobReloader) ReloadAll(o *models.JobSlice, ctx context.Context, exec boil.ContextExecutor) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReloadAll", o, ctx, exec)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReloadAll indicates an expected call of ReloadAll.
func (mr *MockJobReloaderMockRecorder) ReloadAll(o, ctx, exec interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReloadAll", reflect.TypeOf((*MockJobReloader)(nil).ReloadAll), o, ctx, exec)
}
