// +build mysql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

type ServicePlanUpserter interface {
	Upsert(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error
}

var mySQLServicePlanUniqueColumns = []string{
	"id",
	"guid",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (q servicePlanQuery) Upsert(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no service_plans provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(servicePlanColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLServicePlanUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	servicePlanUpsertCacheMut.RLock()
	cache, cached := servicePlanUpsertCache[key]
	servicePlanUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			servicePlanAllColumns,
			servicePlanColumnsWithDefault,
			servicePlanColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			servicePlanAllColumns,
			servicePlanPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert service_plans, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`service_plans`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `service_plans` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(servicePlanType, servicePlanMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(servicePlanType, servicePlanMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for service_plans")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == servicePlanMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(servicePlanType, servicePlanMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for service_plans")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for service_plans")
	}

CacheNoHooks:
	if !cached {
		servicePlanUpsertCacheMut.Lock()
		servicePlanUpsertCache[key] = cache
		servicePlanUpsertCacheMut.Unlock()
	}

	return nil
}

// ServicePlan is an object representing the database table.
type ServicePlan struct {
	ID                     int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                   string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt              time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt              null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Name                   string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Description            string      `boil:"description" json:"description" toml:"description" yaml:"description"`
	Free                   bool        `boil:"free" json:"free" toml:"free" yaml:"free"`
	ServiceID              int         `boil:"service_id" json:"service_id" toml:"service_id" yaml:"service_id"`
	Extra                  null.String `boil:"extra" json:"extra,omitempty" toml:"extra" yaml:"extra,omitempty"`
	UniqueID               string      `boil:"unique_id" json:"unique_id" toml:"unique_id" yaml:"unique_id"`
	Public                 null.Bool   `boil:"public" json:"public,omitempty" toml:"public" yaml:"public,omitempty"`
	Active                 null.Bool   `boil:"active" json:"active,omitempty" toml:"active" yaml:"active,omitempty"`
	Bindable               null.Bool   `boil:"bindable" json:"bindable,omitempty" toml:"bindable" yaml:"bindable,omitempty"`
	CreateInstanceSchema   null.String `boil:"create_instance_schema" json:"create_instance_schema,omitempty" toml:"create_instance_schema" yaml:"create_instance_schema,omitempty"`
	UpdateInstanceSchema   null.String `boil:"update_instance_schema" json:"update_instance_schema,omitempty" toml:"update_instance_schema" yaml:"update_instance_schema,omitempty"`
	CreateBindingSchema    null.String `boil:"create_binding_schema" json:"create_binding_schema,omitempty" toml:"create_binding_schema" yaml:"create_binding_schema,omitempty"`
	PlanUpdateable         null.Bool   `boil:"plan_updateable" json:"plan_updateable,omitempty" toml:"plan_updateable" yaml:"plan_updateable,omitempty"`
	MaximumPollingDuration null.Int    `boil:"maximum_polling_duration" json:"maximum_polling_duration,omitempty" toml:"maximum_polling_duration" yaml:"maximum_polling_duration,omitempty"`
	MaintenanceInfo        null.String `boil:"maintenance_info" json:"maintenance_info,omitempty" toml:"maintenance_info" yaml:"maintenance_info,omitempty"`

	R *servicePlanR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L servicePlanL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ServicePlanColumns = struct {
	ID                     string
	GUID                   string
	CreatedAt              string
	UpdatedAt              string
	Name                   string
	Description            string
	Free                   string
	ServiceID              string
	Extra                  string
	UniqueID               string
	Public                 string
	Active                 string
	Bindable               string
	CreateInstanceSchema   string
	UpdateInstanceSchema   string
	CreateBindingSchema    string
	PlanUpdateable         string
	MaximumPollingDuration string
	MaintenanceInfo        string
}{
	ID:                     "id",
	GUID:                   "guid",
	CreatedAt:              "created_at",
	UpdatedAt:              "updated_at",
	Name:                   "name",
	Description:            "description",
	Free:                   "free",
	ServiceID:              "service_id",
	Extra:                  "extra",
	UniqueID:               "unique_id",
	Public:                 "public",
	Active:                 "active",
	Bindable:               "bindable",
	CreateInstanceSchema:   "create_instance_schema",
	UpdateInstanceSchema:   "update_instance_schema",
	CreateBindingSchema:    "create_binding_schema",
	PlanUpdateable:         "plan_updateable",
	MaximumPollingDuration: "maximum_polling_duration",
	MaintenanceInfo:        "maintenance_info",
}

var ServicePlanTableColumns = struct {
	ID                     string
	GUID                   string
	CreatedAt              string
	UpdatedAt              string
	Name                   string
	Description            string
	Free                   string
	ServiceID              string
	Extra                  string
	UniqueID               string
	Public                 string
	Active                 string
	Bindable               string
	CreateInstanceSchema   string
	UpdateInstanceSchema   string
	CreateBindingSchema    string
	PlanUpdateable         string
	MaximumPollingDuration string
	MaintenanceInfo        string
}{
	ID:                     "service_plans.id",
	GUID:                   "service_plans.guid",
	CreatedAt:              "service_plans.created_at",
	UpdatedAt:              "service_plans.updated_at",
	Name:                   "service_plans.name",
	Description:            "service_plans.description",
	Free:                   "service_plans.free",
	ServiceID:              "service_plans.service_id",
	Extra:                  "service_plans.extra",
	UniqueID:               "service_plans.unique_id",
	Public:                 "service_plans.public",
	Active:                 "service_plans.active",
	Bindable:               "service_plans.bindable",
	CreateInstanceSchema:   "service_plans.create_instance_schema",
	UpdateInstanceSchema:   "service_plans.update_instance_schema",
	CreateBindingSchema:    "service_plans.create_binding_schema",
	PlanUpdateable:         "service_plans.plan_updateable",
	MaximumPollingDuration: "service_plans.maximum_polling_duration",
	MaintenanceInfo:        "service_plans.maintenance_info",
}

// Generated where

var ServicePlanWhere = struct {
	ID                     whereHelperint
	GUID                   whereHelperstring
	CreatedAt              whereHelpertime_Time
	UpdatedAt              whereHelpernull_Time
	Name                   whereHelperstring
	Description            whereHelperstring
	Free                   whereHelperbool
	ServiceID              whereHelperint
	Extra                  whereHelpernull_String
	UniqueID               whereHelperstring
	Public                 whereHelpernull_Bool
	Active                 whereHelpernull_Bool
	Bindable               whereHelpernull_Bool
	CreateInstanceSchema   whereHelpernull_String
	UpdateInstanceSchema   whereHelpernull_String
	CreateBindingSchema    whereHelpernull_String
	PlanUpdateable         whereHelpernull_Bool
	MaximumPollingDuration whereHelpernull_Int
	MaintenanceInfo        whereHelpernull_String
}{
	ID:                     whereHelperint{field: "`service_plans`.`id`"},
	GUID:                   whereHelperstring{field: "`service_plans`.`guid`"},
	CreatedAt:              whereHelpertime_Time{field: "`service_plans`.`created_at`"},
	UpdatedAt:              whereHelpernull_Time{field: "`service_plans`.`updated_at`"},
	Name:                   whereHelperstring{field: "`service_plans`.`name`"},
	Description:            whereHelperstring{field: "`service_plans`.`description`"},
	Free:                   whereHelperbool{field: "`service_plans`.`free`"},
	ServiceID:              whereHelperint{field: "`service_plans`.`service_id`"},
	Extra:                  whereHelpernull_String{field: "`service_plans`.`extra`"},
	UniqueID:               whereHelperstring{field: "`service_plans`.`unique_id`"},
	Public:                 whereHelpernull_Bool{field: "`service_plans`.`public`"},
	Active:                 whereHelpernull_Bool{field: "`service_plans`.`active`"},
	Bindable:               whereHelpernull_Bool{field: "`service_plans`.`bindable`"},
	CreateInstanceSchema:   whereHelpernull_String{field: "`service_plans`.`create_instance_schema`"},
	UpdateInstanceSchema:   whereHelpernull_String{field: "`service_plans`.`update_instance_schema`"},
	CreateBindingSchema:    whereHelpernull_String{field: "`service_plans`.`create_binding_schema`"},
	PlanUpdateable:         whereHelpernull_Bool{field: "`service_plans`.`plan_updateable`"},
	MaximumPollingDuration: whereHelpernull_Int{field: "`service_plans`.`maximum_polling_duration`"},
	MaintenanceInfo:        whereHelpernull_String{field: "`service_plans`.`maintenance_info`"},
}

// ServicePlanRels is where relationship names are stored.
var ServicePlanRels = struct {
	Service                        string
	ServiceInstances               string
	ResourceServicePlanAnnotations string
	ResourceServicePlanLabels      string
	ServicePlanVisibilities        string
}{
	Service:                        "Service",
	ServiceInstances:               "ServiceInstances",
	ResourceServicePlanAnnotations: "ResourceServicePlanAnnotations",
	ResourceServicePlanLabels:      "ResourceServicePlanLabels",
	ServicePlanVisibilities:        "ServicePlanVisibilities",
}

// servicePlanR is where relationships are stored.
type servicePlanR struct {
	Service                        *Service                   `boil:"Service" json:"Service" toml:"Service" yaml:"Service"`
	ServiceInstances               ServiceInstanceSlice       `boil:"ServiceInstances" json:"ServiceInstances" toml:"ServiceInstances" yaml:"ServiceInstances"`
	ResourceServicePlanAnnotations ServicePlanAnnotationSlice `boil:"ResourceServicePlanAnnotations" json:"ResourceServicePlanAnnotations" toml:"ResourceServicePlanAnnotations" yaml:"ResourceServicePlanAnnotations"`
	ResourceServicePlanLabels      ServicePlanLabelSlice      `boil:"ResourceServicePlanLabels" json:"ResourceServicePlanLabels" toml:"ResourceServicePlanLabels" yaml:"ResourceServicePlanLabels"`
	ServicePlanVisibilities        ServicePlanVisibilitySlice `boil:"ServicePlanVisibilities" json:"ServicePlanVisibilities" toml:"ServicePlanVisibilities" yaml:"ServicePlanVisibilities"`
}

// NewStruct creates a new relationship struct
func (*servicePlanR) NewStruct() *servicePlanR {
	return &servicePlanR{}
}

// servicePlanL is where Load methods for each relationship are stored.
type servicePlanL struct{}

var (
	servicePlanAllColumns            = []string{"id", "guid", "created_at", "updated_at", "name", "description", "free", "service_id", "extra", "unique_id", "public", "active", "bindable", "create_instance_schema", "update_instance_schema", "create_binding_schema", "plan_updateable", "maximum_polling_duration", "maintenance_info"}
	servicePlanColumnsWithoutDefault = []string{"guid", "updated_at", "name", "description", "free", "service_id", "extra", "unique_id", "bindable", "create_instance_schema", "update_instance_schema", "create_binding_schema", "plan_updateable", "maximum_polling_duration", "maintenance_info"}
	servicePlanColumnsWithDefault    = []string{"id", "created_at", "public", "active"}
	servicePlanPrimaryKeyColumns     = []string{"id"}
)

type (
	// ServicePlanSlice is an alias for a slice of pointers to ServicePlan.
	// This should almost always be used instead of []ServicePlan.
	ServicePlanSlice []*ServicePlan

	servicePlanQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	servicePlanType                 = reflect.TypeOf(&ServicePlan{})
	servicePlanMapping              = queries.MakeStructMapping(servicePlanType)
	servicePlanPrimaryKeyMapping, _ = queries.BindMapping(servicePlanType, servicePlanMapping, servicePlanPrimaryKeyColumns)
	servicePlanInsertCacheMut       sync.RWMutex
	servicePlanInsertCache          = make(map[string]insertCache)
	servicePlanUpdateCacheMut       sync.RWMutex
	servicePlanUpdateCache          = make(map[string]updateCache)
	servicePlanUpsertCacheMut       sync.RWMutex
	servicePlanUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type ServicePlanFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*ServicePlan, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (ServicePlanSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single servicePlan record from the query.
func (q servicePlanQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ServicePlan, error) {
	o := &ServicePlan{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for service_plans")
	}

	return o, nil
}

// All returns all ServicePlan records from the query.
func (q servicePlanQuery) All(ctx context.Context, exec boil.ContextExecutor) (ServicePlanSlice, error) {
	var o []*ServicePlan

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to ServicePlan slice")
	}

	return o, nil
}

// Count returns the count of all ServicePlan records in the query.
func (q servicePlanQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count service_plans rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q servicePlanQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if service_plans exists")
	}

	return count > 0, nil
}

// Service pointed to by the foreign key.
func (q servicePlanQuery) Service(o *ServicePlan, mods ...qm.QueryMod) serviceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.ServiceID),
	}

	queryMods = append(queryMods, mods...)

	query := Services(queryMods...)
	queries.SetFrom(query.Query, "`services`")

	return query
}

// ServiceInstances retrieves all the service_instance's ServiceInstances with an executor.
func (q servicePlanQuery) ServiceInstances(o *ServicePlan, mods ...qm.QueryMod) serviceInstanceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`service_instances`.`service_plan_id`=?", o.ID),
	)

	query := ServiceInstances(queryMods...)
	queries.SetFrom(query.Query, "`service_instances`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`service_instances`.*"})
	}

	return query
}

// ResourceServicePlanAnnotations retrieves all the service_plan_annotation's ServicePlanAnnotations with an executor via resource_guid column.
func (q servicePlanQuery) ResourceServicePlanAnnotations(o *ServicePlan, mods ...qm.QueryMod) servicePlanAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`service_plan_annotations`.`resource_guid`=?", o.GUID),
	)

	query := ServicePlanAnnotations(queryMods...)
	queries.SetFrom(query.Query, "`service_plan_annotations`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`service_plan_annotations`.*"})
	}

	return query
}

// ResourceServicePlanLabels retrieves all the service_plan_label's ServicePlanLabels with an executor via resource_guid column.
func (q servicePlanQuery) ResourceServicePlanLabels(o *ServicePlan, mods ...qm.QueryMod) servicePlanLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`service_plan_labels`.`resource_guid`=?", o.GUID),
	)

	query := ServicePlanLabels(queryMods...)
	queries.SetFrom(query.Query, "`service_plan_labels`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`service_plan_labels`.*"})
	}

	return query
}

// ServicePlanVisibilities retrieves all the service_plan_visibility's ServicePlanVisibilities with an executor.
func (q servicePlanQuery) ServicePlanVisibilities(o *ServicePlan, mods ...qm.QueryMod) servicePlanVisibilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`service_plan_visibilities`.`service_plan_id`=?", o.ID),
	)

	query := ServicePlanVisibilities(queryMods...)
	queries.SetFrom(query.Query, "`service_plan_visibilities`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`service_plan_visibilities`.*"})
	}

	return query
}

// LoadService allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (servicePlanL) LoadService(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServicePlan interface{}, mods queries.Applicator) error {
	var slice []*ServicePlan
	var object *ServicePlan

	if singular {
		object = maybeServicePlan.(*ServicePlan)
	} else {
		slice = *maybeServicePlan.(*[]*ServicePlan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &servicePlanR{}
		}
		args = append(args, object.ServiceID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &servicePlanR{}
			}

			for _, a := range args {
				if a == obj.ServiceID {
					continue Outer
				}
			}

			args = append(args, obj.ServiceID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`services`),
		qm.WhereIn(`services.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Service")
	}

	var resultSlice []*Service
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Service")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for services")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for services")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Service = foreign
		if foreign.R == nil {
			foreign.R = &serviceR{}
		}
		foreign.R.ServicePlans = append(foreign.R.ServicePlans, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ServiceID == foreign.ID {
				local.R.Service = foreign
				if foreign.R == nil {
					foreign.R = &serviceR{}
				}
				foreign.R.ServicePlans = append(foreign.R.ServicePlans, local)
				break
			}
		}
	}

	return nil
}

// LoadServiceInstances allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (servicePlanL) LoadServiceInstances(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServicePlan interface{}, mods queries.Applicator) error {
	var slice []*ServicePlan
	var object *ServicePlan

	if singular {
		object = maybeServicePlan.(*ServicePlan)
	} else {
		slice = *maybeServicePlan.(*[]*ServicePlan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &servicePlanR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &servicePlanR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_instances`),
		qm.WhereIn(`service_instances.service_plan_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_instances")
	}

	var resultSlice []*ServiceInstance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_instances")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_instances")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_instances")
	}

	if singular {
		object.R.ServiceInstances = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &serviceInstanceR{}
			}
			foreign.R.ServicePlan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ServicePlanID) {
				local.R.ServiceInstances = append(local.R.ServiceInstances, foreign)
				if foreign.R == nil {
					foreign.R = &serviceInstanceR{}
				}
				foreign.R.ServicePlan = local
				break
			}
		}
	}

	return nil
}

// LoadResourceServicePlanAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (servicePlanL) LoadResourceServicePlanAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServicePlan interface{}, mods queries.Applicator) error {
	var slice []*ServicePlan
	var object *ServicePlan

	if singular {
		object = maybeServicePlan.(*ServicePlan)
	} else {
		slice = *maybeServicePlan.(*[]*ServicePlan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &servicePlanR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &servicePlanR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_plan_annotations`),
		qm.WhereIn(`service_plan_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_plan_annotations")
	}

	var resultSlice []*ServicePlanAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_plan_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_plan_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_plan_annotations")
	}

	if singular {
		object.R.ResourceServicePlanAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &servicePlanAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServicePlanAnnotations = append(local.R.ResourceServicePlanAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &servicePlanAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourceServicePlanLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (servicePlanL) LoadResourceServicePlanLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServicePlan interface{}, mods queries.Applicator) error {
	var slice []*ServicePlan
	var object *ServicePlan

	if singular {
		object = maybeServicePlan.(*ServicePlan)
	} else {
		slice = *maybeServicePlan.(*[]*ServicePlan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &servicePlanR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &servicePlanR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_plan_labels`),
		qm.WhereIn(`service_plan_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_plan_labels")
	}

	var resultSlice []*ServicePlanLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_plan_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_plan_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_plan_labels")
	}

	if singular {
		object.R.ResourceServicePlanLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &servicePlanLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourceServicePlanLabels = append(local.R.ResourceServicePlanLabels, foreign)
				if foreign.R == nil {
					foreign.R = &servicePlanLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadServicePlanVisibilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (servicePlanL) LoadServicePlanVisibilities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeServicePlan interface{}, mods queries.Applicator) error {
	var slice []*ServicePlan
	var object *ServicePlan

	if singular {
		object = maybeServicePlan.(*ServicePlan)
	} else {
		slice = *maybeServicePlan.(*[]*ServicePlan)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &servicePlanR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &servicePlanR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`service_plan_visibilities`),
		qm.WhereIn(`service_plan_visibilities.service_plan_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load service_plan_visibilities")
	}

	var resultSlice []*ServicePlanVisibility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice service_plan_visibilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on service_plan_visibilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for service_plan_visibilities")
	}

	if singular {
		object.R.ServicePlanVisibilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &servicePlanVisibilityR{}
			}
			foreign.R.ServicePlan = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ServicePlanID {
				local.R.ServicePlanVisibilities = append(local.R.ServicePlanVisibilities, foreign)
				if foreign.R == nil {
					foreign.R = &servicePlanVisibilityR{}
				}
				foreign.R.ServicePlan = local
				break
			}
		}
	}

	return nil
}

// SetService of the servicePlan to the related item.
// Sets o.R.Service to related.
// Adds o to related.R.ServicePlans.
func (q servicePlanQuery) SetService(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related *Service) error {
	var err error
	if insert {
		if err = Services().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `service_plans` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"service_id"}),
		strmangle.WhereClause("`", "`", 0, servicePlanPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ServiceID = related.ID
	if o.R == nil {
		o.R = &servicePlanR{
			Service: related,
		}
	} else {
		o.R.Service = related
	}

	if related.R == nil {
		related.R = &serviceR{
			ServicePlans: ServicePlanSlice{o},
		}
	} else {
		related.R.ServicePlans = append(related.R.ServicePlans, o)
	}

	return nil
}

// AddServiceInstances adds the given related objects to the existing relationships
// of the service_plan, optionally inserting them as new records.
// Appends related to o.R.ServiceInstances.
// Sets related.R.ServicePlan appropriately.
func (q servicePlanQuery) AddServiceInstances(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstance) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ServicePlanID, o.ID)
			if err = ServiceInstances().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `service_instances` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"service_plan_id"}),
				strmangle.WhereClause("`", "`", 0, serviceInstancePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ServicePlanID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &servicePlanR{
			ServiceInstances: related,
		}
	} else {
		o.R.ServiceInstances = append(o.R.ServiceInstances, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &serviceInstanceR{
				ServicePlan: o,
			}
		} else {
			rel.R.ServicePlan = o
		}
	}
	return nil
}

// SetServiceInstances removes all previously related items of the
// service_plan replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ServicePlan's ServiceInstances accordingly.
// Replaces o.R.ServiceInstances with related.
// Sets related.R.ServicePlan's ServiceInstances accordingly.
func (q servicePlanQuery) SetServiceInstances(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServiceInstance) error {
	query := "update `service_instances` set `service_plan_id` = null where `service_plan_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ServiceInstances {
			queries.SetScanner(&rel.ServicePlanID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ServicePlan = nil
		}

		o.R.ServiceInstances = nil
	}
	return q.AddServiceInstances(o, ctx, exec, insert, related...)
}

// RemoveServiceInstances relationships from objects passed in.
// Removes related items from R.ServiceInstances (uses pointer comparison, removal does not keep order)
// Sets related.R.ServicePlan.
func (q servicePlanQuery) RemoveServiceInstances(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, related ...*ServiceInstance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ServicePlanID, nil)
		if rel.R != nil {
			rel.R.ServicePlan = nil
		}
		if _, err = ServiceInstances().Update(rel, ctx, exec, boil.Whitelist("service_plan_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ServiceInstances {
			if rel != ri {
				continue
			}

			ln := len(o.R.ServiceInstances)
			if ln > 1 && i < ln-1 {
				o.R.ServiceInstances[i] = o.R.ServiceInstances[ln-1]
			}
			o.R.ServiceInstances = o.R.ServiceInstances[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceServicePlanAnnotations adds the given related objects to the existing relationships
// of the service_plan, optionally inserting them as new records.
// Appends related to o.R.ResourceServicePlanAnnotations.
// Sets related.R.Resource appropriately.
func (q servicePlanQuery) AddResourceServicePlanAnnotations(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlanAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ServicePlanAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `service_plan_annotations` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, servicePlanAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &servicePlanR{
			ResourceServicePlanAnnotations: related,
		}
	} else {
		o.R.ResourceServicePlanAnnotations = append(o.R.ResourceServicePlanAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &servicePlanAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServicePlanAnnotations removes all previously related items of the
// service_plan replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServicePlanAnnotations accordingly.
// Replaces o.R.ResourceServicePlanAnnotations with related.
// Sets related.R.Resource's ResourceServicePlanAnnotations accordingly.
func (q servicePlanQuery) SetResourceServicePlanAnnotations(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlanAnnotation) error {
	query := "update `service_plan_annotations` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServicePlanAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServicePlanAnnotations = nil
	}
	return q.AddResourceServicePlanAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourceServicePlanAnnotations relationships from objects passed in.
// Removes related items from R.ResourceServicePlanAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q servicePlanQuery) RemoveResourceServicePlanAnnotations(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, related ...*ServicePlanAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ServicePlanAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServicePlanAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServicePlanAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServicePlanAnnotations[i] = o.R.ResourceServicePlanAnnotations[ln-1]
			}
			o.R.ResourceServicePlanAnnotations = o.R.ResourceServicePlanAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourceServicePlanLabels adds the given related objects to the existing relationships
// of the service_plan, optionally inserting them as new records.
// Appends related to o.R.ResourceServicePlanLabels.
// Sets related.R.Resource appropriately.
func (q servicePlanQuery) AddResourceServicePlanLabels(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlanLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = ServicePlanLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `service_plan_labels` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, servicePlanLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &servicePlanR{
			ResourceServicePlanLabels: related,
		}
	} else {
		o.R.ResourceServicePlanLabels = append(o.R.ResourceServicePlanLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &servicePlanLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourceServicePlanLabels removes all previously related items of the
// service_plan replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourceServicePlanLabels accordingly.
// Replaces o.R.ResourceServicePlanLabels with related.
// Sets related.R.Resource's ResourceServicePlanLabels accordingly.
func (q servicePlanQuery) SetResourceServicePlanLabels(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlanLabel) error {
	query := "update `service_plan_labels` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourceServicePlanLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourceServicePlanLabels = nil
	}
	return q.AddResourceServicePlanLabels(o, ctx, exec, insert, related...)
}

// RemoveResourceServicePlanLabels relationships from objects passed in.
// Removes related items from R.ResourceServicePlanLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q servicePlanQuery) RemoveResourceServicePlanLabels(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, related ...*ServicePlanLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = ServicePlanLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourceServicePlanLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourceServicePlanLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourceServicePlanLabels[i] = o.R.ResourceServicePlanLabels[ln-1]
			}
			o.R.ResourceServicePlanLabels = o.R.ResourceServicePlanLabels[:ln-1]
			break
		}
	}

	return nil
}

// AddServicePlanVisibilities adds the given related objects to the existing relationships
// of the service_plan, optionally inserting them as new records.
// Appends related to o.R.ServicePlanVisibilities.
// Sets related.R.ServicePlan appropriately.
func (q servicePlanQuery) AddServicePlanVisibilities(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ServicePlanVisibility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ServicePlanID = o.ID
			if err = ServicePlanVisibilities().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `service_plan_visibilities` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"service_plan_id"}),
				strmangle.WhereClause("`", "`", 0, servicePlanVisibilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ServicePlanID = o.ID
		}
	}

	if o.R == nil {
		o.R = &servicePlanR{
			ServicePlanVisibilities: related,
		}
	} else {
		o.R.ServicePlanVisibilities = append(o.R.ServicePlanVisibilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &servicePlanVisibilityR{
				ServicePlan: o,
			}
		} else {
			rel.R.ServicePlan = o
		}
	}
	return nil
}

// ServicePlans retrieves all the records using an executor.
func ServicePlans(mods ...qm.QueryMod) servicePlanQuery {
	mods = append(mods, qm.From("`service_plans`"))
	return servicePlanQuery{NewQuery(mods...)}
}

type ServicePlanFinder interface {
	FindServicePlan(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*ServicePlan, error)
}

// FindServicePlan retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindServicePlan(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*ServicePlan, error) {
	servicePlanObj := &ServicePlan{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `service_plans` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, servicePlanObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from service_plans")
	}

	return servicePlanObj, nil
}

type ServicePlanInserter interface {
	Insert(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q servicePlanQuery) Insert(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no service_plans provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(servicePlanColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	servicePlanInsertCacheMut.RLock()
	cache, cached := servicePlanInsertCache[key]
	servicePlanInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			servicePlanAllColumns,
			servicePlanColumnsWithDefault,
			servicePlanColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(servicePlanType, servicePlanMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(servicePlanType, servicePlanMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `service_plans` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `service_plans` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `service_plans` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, servicePlanPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into service_plans")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == servicePlanMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for service_plans")
	}

CacheNoHooks:
	if !cached {
		servicePlanInsertCacheMut.Lock()
		servicePlanInsertCache[key] = cache
		servicePlanInsertCacheMut.Unlock()
	}

	return nil
}

type ServicePlanUpdater interface {
	Update(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the ServicePlan.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q servicePlanQuery) Update(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	servicePlanUpdateCacheMut.RLock()
	cache, cached := servicePlanUpdateCache[key]
	servicePlanUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			servicePlanAllColumns,
			servicePlanPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update service_plans, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `service_plans` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, servicePlanPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(servicePlanType, servicePlanMapping, append(wl, servicePlanPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update service_plans row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for service_plans")
	}

	if !cached {
		servicePlanUpdateCacheMut.Lock()
		servicePlanUpdateCache[key] = cache
		servicePlanUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q servicePlanQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for service_plans")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for service_plans")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q servicePlanQuery) UpdateAllSlice(o ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePlanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `service_plans` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, servicePlanPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in servicePlan slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all servicePlan")
	}
	return rowsAff, nil
}

type ServicePlanDeleter interface {
	Delete(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single ServicePlan record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q servicePlanQuery) Delete(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no ServicePlan provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), servicePlanPrimaryKeyMapping)
	sql := "DELETE FROM `service_plans` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from service_plans")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for service_plans")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q servicePlanQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no servicePlanQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from service_plans")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for service_plans")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q servicePlanQuery) DeleteAllSlice(o ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePlanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `service_plans` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, servicePlanPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from servicePlan slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for service_plans")
	}

	return rowsAff, nil
}

type ServicePlanReloader interface {
	Reload(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q servicePlanQuery) Reload(o *ServicePlan, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindServicePlan(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q servicePlanQuery) ReloadAll(o *ServicePlanSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ServicePlanSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), servicePlanPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `service_plans`.* FROM `service_plans` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, servicePlanPrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ServicePlanSlice")
	}

	*o = slice

	return nil
}

// ServicePlanExists checks if the ServicePlan row exists.
func ServicePlanExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `service_plans` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if service_plans exists")
	}

	return exists, nil
}
