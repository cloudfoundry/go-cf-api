// +build mysql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Package is an object representing the database table.
type Package struct {
	ID                      int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                    string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt               time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt               null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Type                    null.String `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	PackageHash             null.String `boil:"package_hash" json:"package_hash,omitempty" toml:"package_hash" yaml:"package_hash,omitempty"`
	State                   string      `boil:"state" json:"state" toml:"state" yaml:"state"`
	Error                   null.String `boil:"error" json:"error,omitempty" toml:"error" yaml:"error,omitempty"`
	AppGUID                 null.String `boil:"app_guid" json:"app_guid,omitempty" toml:"app_guid" yaml:"app_guid,omitempty"`
	DockerImage             null.String `boil:"docker_image" json:"docker_image,omitempty" toml:"docker_image" yaml:"docker_image,omitempty"`
	Sha256Checksum          null.String `boil:"sha256_checksum" json:"sha256_checksum,omitempty" toml:"sha256_checksum" yaml:"sha256_checksum,omitempty"`
	DockerUsername          null.String `boil:"docker_username" json:"docker_username,omitempty" toml:"docker_username" yaml:"docker_username,omitempty"`
	DockerPasswordSalt      null.String `boil:"docker_password_salt" json:"docker_password_salt,omitempty" toml:"docker_password_salt" yaml:"docker_password_salt,omitempty"`
	EncryptedDockerPassword null.String `boil:"encrypted_docker_password" json:"encrypted_docker_password,omitempty" toml:"encrypted_docker_password" yaml:"encrypted_docker_password,omitempty"`
	EncryptionKeyLabel      null.String `boil:"encryption_key_label" json:"encryption_key_label,omitempty" toml:"encryption_key_label" yaml:"encryption_key_label,omitempty"`
	EncryptionIterations    int         `boil:"encryption_iterations" json:"encryption_iterations" toml:"encryption_iterations" yaml:"encryption_iterations"`

	R *packageR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L packageL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PackageColumns = struct {
	ID                      string
	GUID                    string
	CreatedAt               string
	UpdatedAt               string
	Type                    string
	PackageHash             string
	State                   string
	Error                   string
	AppGUID                 string
	DockerImage             string
	Sha256Checksum          string
	DockerUsername          string
	DockerPasswordSalt      string
	EncryptedDockerPassword string
	EncryptionKeyLabel      string
	EncryptionIterations    string
}{
	ID:                      "id",
	GUID:                    "guid",
	CreatedAt:               "created_at",
	UpdatedAt:               "updated_at",
	Type:                    "type",
	PackageHash:             "package_hash",
	State:                   "state",
	Error:                   "error",
	AppGUID:                 "app_guid",
	DockerImage:             "docker_image",
	Sha256Checksum:          "sha256_checksum",
	DockerUsername:          "docker_username",
	DockerPasswordSalt:      "docker_password_salt",
	EncryptedDockerPassword: "encrypted_docker_password",
	EncryptionKeyLabel:      "encryption_key_label",
	EncryptionIterations:    "encryption_iterations",
}

var PackageTableColumns = struct {
	ID                      string
	GUID                    string
	CreatedAt               string
	UpdatedAt               string
	Type                    string
	PackageHash             string
	State                   string
	Error                   string
	AppGUID                 string
	DockerImage             string
	Sha256Checksum          string
	DockerUsername          string
	DockerPasswordSalt      string
	EncryptedDockerPassword string
	EncryptionKeyLabel      string
	EncryptionIterations    string
}{
	ID:                      "packages.id",
	GUID:                    "packages.guid",
	CreatedAt:               "packages.created_at",
	UpdatedAt:               "packages.updated_at",
	Type:                    "packages.type",
	PackageHash:             "packages.package_hash",
	State:                   "packages.state",
	Error:                   "packages.error",
	AppGUID:                 "packages.app_guid",
	DockerImage:             "packages.docker_image",
	Sha256Checksum:          "packages.sha256_checksum",
	DockerUsername:          "packages.docker_username",
	DockerPasswordSalt:      "packages.docker_password_salt",
	EncryptedDockerPassword: "packages.encrypted_docker_password",
	EncryptionKeyLabel:      "packages.encryption_key_label",
	EncryptionIterations:    "packages.encryption_iterations",
}

// Generated where

var PackageWhere = struct {
	ID                      whereHelperint
	GUID                    whereHelperstring
	CreatedAt               whereHelpertime_Time
	UpdatedAt               whereHelpernull_Time
	Type                    whereHelpernull_String
	PackageHash             whereHelpernull_String
	State                   whereHelperstring
	Error                   whereHelpernull_String
	AppGUID                 whereHelpernull_String
	DockerImage             whereHelpernull_String
	Sha256Checksum          whereHelpernull_String
	DockerUsername          whereHelpernull_String
	DockerPasswordSalt      whereHelpernull_String
	EncryptedDockerPassword whereHelpernull_String
	EncryptionKeyLabel      whereHelpernull_String
	EncryptionIterations    whereHelperint
}{
	ID:                      whereHelperint{field: "`packages`.`id`"},
	GUID:                    whereHelperstring{field: "`packages`.`guid`"},
	CreatedAt:               whereHelpertime_Time{field: "`packages`.`created_at`"},
	UpdatedAt:               whereHelpernull_Time{field: "`packages`.`updated_at`"},
	Type:                    whereHelpernull_String{field: "`packages`.`type`"},
	PackageHash:             whereHelpernull_String{field: "`packages`.`package_hash`"},
	State:                   whereHelperstring{field: "`packages`.`state`"},
	Error:                   whereHelpernull_String{field: "`packages`.`error`"},
	AppGUID:                 whereHelpernull_String{field: "`packages`.`app_guid`"},
	DockerImage:             whereHelpernull_String{field: "`packages`.`docker_image`"},
	Sha256Checksum:          whereHelpernull_String{field: "`packages`.`sha256_checksum`"},
	DockerUsername:          whereHelpernull_String{field: "`packages`.`docker_username`"},
	DockerPasswordSalt:      whereHelpernull_String{field: "`packages`.`docker_password_salt`"},
	EncryptedDockerPassword: whereHelpernull_String{field: "`packages`.`encrypted_docker_password`"},
	EncryptionKeyLabel:      whereHelpernull_String{field: "`packages`.`encryption_key_label`"},
	EncryptionIterations:    whereHelperint{field: "`packages`.`encryption_iterations`"},
}

// PackageRels is where relationship names are stored.
var PackageRels = struct {
	App                        string
	ResourcePackageAnnotations string
	ResourcePackageLabels      string
}{
	App:                        "App",
	ResourcePackageAnnotations: "ResourcePackageAnnotations",
	ResourcePackageLabels:      "ResourcePackageLabels",
}

// packageR is where relationships are stored.
type packageR struct {
	App                        *App                   `boil:"App" json:"App" toml:"App" yaml:"App"`
	ResourcePackageAnnotations PackageAnnotationSlice `boil:"ResourcePackageAnnotations" json:"ResourcePackageAnnotations" toml:"ResourcePackageAnnotations" yaml:"ResourcePackageAnnotations"`
	ResourcePackageLabels      PackageLabelSlice      `boil:"ResourcePackageLabels" json:"ResourcePackageLabels" toml:"ResourcePackageLabels" yaml:"ResourcePackageLabels"`
}

// NewStruct creates a new relationship struct
func (*packageR) NewStruct() *packageR {
	return &packageR{}
}

// packageL is where Load methods for each relationship are stored.
type packageL struct{}

var (
	packageAllColumns            = []string{"id", "guid", "created_at", "updated_at", "type", "package_hash", "state", "error", "app_guid", "docker_image", "sha256_checksum", "docker_username", "docker_password_salt", "encrypted_docker_password", "encryption_key_label", "encryption_iterations"}
	packageColumnsWithoutDefault = []string{"guid", "updated_at", "type", "package_hash", "state", "error", "app_guid", "docker_image", "sha256_checksum", "docker_username", "docker_password_salt", "encrypted_docker_password", "encryption_key_label"}
	packageColumnsWithDefault    = []string{"id", "created_at", "encryption_iterations"}
	packagePrimaryKeyColumns     = []string{"id"}
)

type (
	// PackageSlice is an alias for a slice of pointers to Package.
	// This should almost always be used instead of []Package.
	PackageSlice []*Package

	PackageQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	packageType                 = reflect.TypeOf(&Package{})
	packageMapping              = queries.MakeStructMapping(packageType)
	packagePrimaryKeyMapping, _ = queries.BindMapping(packageType, packageMapping, packagePrimaryKeyColumns)
	packageInsertCacheMut       sync.RWMutex
	packageInsertCache          = make(map[string]insertCache)
	packageUpdateCacheMut       sync.RWMutex
	packageUpdateCache          = make(map[string]updateCache)
	packageUpsertCacheMut       sync.RWMutex
	packageUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

type PackageFinisher interface {
	One(ctx context.Context, exec boil.ContextExecutor) (*Package, error)
	Count(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	All(ctx context.Context, exec boil.ContextExecutor) (PackageSlice, error)
	Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error)
}

// One returns a single package record from the query.
func (q PackageQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Package, error) {
	o := &Package{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for packages")
	}

	return o, nil
}

// All returns all Package records from the query.
func (q PackageQuery) All(ctx context.Context, exec boil.ContextExecutor) (PackageSlice, error) {
	var o []*Package

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Package slice")
	}

	return o, nil
}

// Count returns the count of all Package records in the query.
func (q PackageQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count packages rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q PackageQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if packages exists")
	}

	return count > 0, nil
}

// App pointed to by the foreign key.
func (q PackageQuery) App(o *Package, mods ...qm.QueryMod) AppQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`guid` = ?", o.AppGUID),
	}

	queryMods = append(queryMods, mods...)

	query := Apps(queryMods...)
	queries.SetFrom(query.Query, "`apps`")

	return query
}

// ResourcePackageAnnotations retrieves all the package_annotation's PackageAnnotations with an executor via resource_guid column.
func (q PackageQuery) ResourcePackageAnnotations(o *Package, mods ...qm.QueryMod) PackageAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`package_annotations`.`resource_guid`=?", o.GUID),
	)

	query := PackageAnnotations(queryMods...)
	queries.SetFrom(query.Query, "`package_annotations`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`package_annotations`.*"})
	}

	return query
}

// ResourcePackageLabels retrieves all the package_label's PackageLabels with an executor via resource_guid column.
func (q PackageQuery) ResourcePackageLabels(o *Package, mods ...qm.QueryMod) PackageLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`package_labels`.`resource_guid`=?", o.GUID),
	)

	query := PackageLabels(queryMods...)
	queries.SetFrom(query.Query, "`package_labels`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`package_labels`.*"})
	}

	return query
}

// LoadApp allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (packageL) LoadApp(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		if !queries.IsNil(object.AppGUID) {
			args = append(args, object.AppGUID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AppGUID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AppGUID) {
				args = append(args, obj.AppGUID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`apps`),
		qm.WhereIn(`apps.guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load App")
	}

	var resultSlice []*App
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice App")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for apps")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for apps")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.App = foreign
		if foreign.R == nil {
			foreign.R = &appR{}
		}
		foreign.R.Packages = append(foreign.R.Packages, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AppGUID, foreign.GUID) {
				local.R.App = foreign
				if foreign.R == nil {
					foreign.R = &appR{}
				}
				foreign.R.Packages = append(foreign.R.Packages, local)
				break
			}
		}
	}

	return nil
}

// LoadResourcePackageAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (packageL) LoadResourcePackageAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`package_annotations`),
		qm.WhereIn(`package_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load package_annotations")
	}

	var resultSlice []*PackageAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice package_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on package_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for package_annotations")
	}

	if singular {
		object.R.ResourcePackageAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &packageAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourcePackageAnnotations = append(local.R.ResourcePackageAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &packageAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourcePackageLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (packageL) LoadResourcePackageLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`package_labels`),
		qm.WhereIn(`package_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load package_labels")
	}

	var resultSlice []*PackageLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice package_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on package_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for package_labels")
	}

	if singular {
		object.R.ResourcePackageLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &packageLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourcePackageLabels = append(local.R.ResourcePackageLabels, foreign)
				if foreign.R == nil {
					foreign.R = &packageLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// SetApp of the package to the related item.
// Sets o.R.App to related.
// Adds o to related.R.Packages.
func (q PackageQuery) SetApp(o *Package, ctx context.Context, exec boil.ContextExecutor, insert bool, related *App) error {
	var err error
	if insert {
		if err = Apps().Insert(related, ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `packages` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"app_guid"}),
		strmangle.WhereClause("`", "`", 0, packagePrimaryKeyColumns),
	)
	values := []interface{}{related.GUID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AppGUID, related.GUID)
	if o.R == nil {
		o.R = &packageR{
			App: related,
		}
	} else {
		o.R.App = related
	}

	if related.R == nil {
		related.R = &appR{
			Packages: PackageSlice{o},
		}
	} else {
		related.R.Packages = append(related.R.Packages, o)
	}

	return nil
}

// RemoveApp relationship.
// Sets o.R.App to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (q PackageQuery) RemoveApp(o *Package, ctx context.Context, exec boil.ContextExecutor, related *App) error {
	var err error

	queries.SetScanner(&o.AppGUID, nil)
	if _, err = q.Update(o, ctx, exec, boil.Whitelist("app_guid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.App = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Packages {
		if queries.Equal(o.AppGUID, ri.AppGUID) {
			continue
		}

		ln := len(related.R.Packages)
		if ln > 1 && i < ln-1 {
			related.R.Packages[i] = related.R.Packages[ln-1]
		}
		related.R.Packages = related.R.Packages[:ln-1]
		break
	}
	return nil
}

// AddResourcePackageAnnotations adds the given related objects to the existing relationships
// of the package, optionally inserting them as new records.
// Appends related to o.R.ResourcePackageAnnotations.
// Sets related.R.Resource appropriately.
func (q PackageQuery) AddResourcePackageAnnotations(o *Package, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = PackageAnnotations().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `package_annotations` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, packageAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &packageR{
			ResourcePackageAnnotations: related,
		}
	} else {
		o.R.ResourcePackageAnnotations = append(o.R.ResourcePackageAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &packageAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourcePackageAnnotations removes all previously related items of the
// package replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourcePackageAnnotations accordingly.
// Replaces o.R.ResourcePackageAnnotations with related.
// Sets related.R.Resource's ResourcePackageAnnotations accordingly.
func (q PackageQuery) SetResourcePackageAnnotations(o *Package, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageAnnotation) error {
	query := "update `package_annotations` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourcePackageAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourcePackageAnnotations = nil
	}
	return q.AddResourcePackageAnnotations(o, ctx, exec, insert, related...)
}

// RemoveResourcePackageAnnotations relationships from objects passed in.
// Removes related items from R.ResourcePackageAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q PackageQuery) RemoveResourcePackageAnnotations(o *Package, ctx context.Context, exec boil.ContextExecutor, related ...*PackageAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = PackageAnnotations().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourcePackageAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourcePackageAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourcePackageAnnotations[i] = o.R.ResourcePackageAnnotations[ln-1]
			}
			o.R.ResourcePackageAnnotations = o.R.ResourcePackageAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourcePackageLabels adds the given related objects to the existing relationships
// of the package, optionally inserting them as new records.
// Appends related to o.R.ResourcePackageLabels.
// Sets related.R.Resource appropriately.
func (q PackageQuery) AddResourcePackageLabels(o *Package, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = PackageLabels().Insert(rel, ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `package_labels` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"resource_guid"}),
				strmangle.WhereClause("`", "`", 0, packageLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &packageR{
			ResourcePackageLabels: related,
		}
	} else {
		o.R.ResourcePackageLabels = append(o.R.ResourcePackageLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &packageLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourcePackageLabels removes all previously related items of the
// package replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourcePackageLabels accordingly.
// Replaces o.R.ResourcePackageLabels with related.
// Sets related.R.Resource's ResourcePackageLabels accordingly.
func (q PackageQuery) SetResourcePackageLabels(o *Package, ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageLabel) error {
	query := "update `package_labels` set `resource_guid` = null where `resource_guid` = ?"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourcePackageLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourcePackageLabels = nil
	}
	return q.AddResourcePackageLabels(o, ctx, exec, insert, related...)
}

// RemoveResourcePackageLabels relationships from objects passed in.
// Removes related items from R.ResourcePackageLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (q PackageQuery) RemoveResourcePackageLabels(o *Package, ctx context.Context, exec boil.ContextExecutor, related ...*PackageLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = PackageLabels().Update(rel, ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourcePackageLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourcePackageLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourcePackageLabels[i] = o.R.ResourcePackageLabels[ln-1]
			}
			o.R.ResourcePackageLabels = o.R.ResourcePackageLabels[:ln-1]
			break
		}
	}

	return nil
}

// Packages retrieves all the records using an executor.
func Packages(mods ...qm.QueryMod) PackageQuery {
	mods = append(mods, qm.From("`packages`"))
	return PackageQuery{NewQuery(mods...)}
}

type PackageFinder interface {
	FindPackage(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Package, error)
}

// FindPackage retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPackage(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Package, error) {
	packageObj := &Package{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `packages` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, packageObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from packages")
	}

	return packageObj, nil
}

type PackageInserter interface {
	Insert(o *Package, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (q PackageQuery) Insert(o *Package, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no packages provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(packageColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	packageInsertCacheMut.RLock()
	cache, cached := packageInsertCache[key]
	packageInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			packageAllColumns,
			packageColumnsWithDefault,
			packageColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(packageType, packageMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `packages` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `packages` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `packages` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, packagePrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into packages")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == packageMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for packages")
	}

CacheNoHooks:
	if !cached {
		packageInsertCacheMut.Lock()
		packageInsertCache[key] = cache
		packageInsertCacheMut.Unlock()
	}

	return nil
}

type PackageUpdater interface {
	Update(o *Package, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error)
	UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
	UpdateAllSlice(o PackageSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error)
}

// Update uses an executor to update the Package.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (q PackageQuery) Update(o *Package, ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	key := makeCacheKey(columns, nil)
	packageUpdateCacheMut.RLock()
	cache, cached := packageUpdateCache[key]
	packageUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			packageAllColumns,
			packagePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update packages, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `packages` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, packagePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, append(wl, packagePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update packages row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for packages")
	}

	if !cached {
		packageUpdateCacheMut.Lock()
		packageUpdateCache[key] = cache
		packageUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q PackageQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for packages")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (q PackageQuery) UpdateAllSlice(o PackageSlice, ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `packages` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, packagePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in package slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all package")
	}
	return rowsAff, nil
}

type PackageDeleter interface {
	Delete(o *Package, ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error)
	DeleteAllSlice(o PackageSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error)
}

// Delete deletes a single Package record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (q PackageQuery) Delete(o *Package, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Package provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), packagePrimaryKeyMapping)
	sql := "DELETE FROM `packages` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for packages")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q PackageQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no packageQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for packages")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (q PackageQuery) DeleteAllSlice(o PackageSlice, ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `packages` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, packagePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from package slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for packages")
	}

	return rowsAff, nil
}

type PackageReloader interface {
	Reload(o *Package, ctx context.Context, exec boil.ContextExecutor) error
	ReloadAll(o *PackageSlice, ctx context.Context, exec boil.ContextExecutor) error
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (q PackageQuery) Reload(o *Package, ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPackage(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (q PackageQuery) ReloadAll(o *PackageSlice, ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PackageSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `packages`.* FROM `packages` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, packagePrimaryKeyColumns, len(*o))

	query := queries.Raw(sql, args...)

	err := query.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PackageSlice")
	}

	*o = slice

	return nil
}

// PackageExists checks if the Package row exists.
func PackageExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `packages` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if packages exists")
	}

	return exists, nil
}

var mySQLPackageUniqueColumns = []string{
	"id",
	"guid",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Package) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no packages provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(packageColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPackageUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	packageUpsertCacheMut.RLock()
	cache, cached := packageUpsertCache[key]
	packageUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			packageAllColumns,
			packageColumnsWithDefault,
			packageColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			packageAllColumns,
			packagePrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert packages, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`packages`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `packages` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(packageType, packageMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for packages")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == packageMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(packageType, packageMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for packages")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for packages")
	}

CacheNoHooks:
	if !cached {
		packageUpsertCacheMut.Lock()
		packageUpsertCache[key] = cache
		packageUpsertCacheMut.Unlock()
	}

	return nil
}
