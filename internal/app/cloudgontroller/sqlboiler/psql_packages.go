// +build psql
// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Package is an object representing the database table.
type Package struct {
	ID                      int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	GUID                    string      `boil:"guid" json:"guid" toml:"guid" yaml:"guid"`
	CreatedAt               time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt               null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Type                    null.String `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	PackageHash             null.String `boil:"package_hash" json:"package_hash,omitempty" toml:"package_hash" yaml:"package_hash,omitempty"`
	State                   string      `boil:"state" json:"state" toml:"state" yaml:"state"`
	Error                   null.String `boil:"error" json:"error,omitempty" toml:"error" yaml:"error,omitempty"`
	AppGUID                 null.String `boil:"app_guid" json:"app_guid,omitempty" toml:"app_guid" yaml:"app_guid,omitempty"`
	DockerImage             null.String `boil:"docker_image" json:"docker_image,omitempty" toml:"docker_image" yaml:"docker_image,omitempty"`
	Sha256Checksum          null.String `boil:"sha256_checksum" json:"sha256_checksum,omitempty" toml:"sha256_checksum" yaml:"sha256_checksum,omitempty"`
	DockerUsername          null.String `boil:"docker_username" json:"docker_username,omitempty" toml:"docker_username" yaml:"docker_username,omitempty"`
	DockerPasswordSalt      null.String `boil:"docker_password_salt" json:"docker_password_salt,omitempty" toml:"docker_password_salt" yaml:"docker_password_salt,omitempty"`
	EncryptedDockerPassword null.String `boil:"encrypted_docker_password" json:"encrypted_docker_password,omitempty" toml:"encrypted_docker_password" yaml:"encrypted_docker_password,omitempty"`
	EncryptionKeyLabel      null.String `boil:"encryption_key_label" json:"encryption_key_label,omitempty" toml:"encryption_key_label" yaml:"encryption_key_label,omitempty"`
	EncryptionIterations    int         `boil:"encryption_iterations" json:"encryption_iterations" toml:"encryption_iterations" yaml:"encryption_iterations"`

	R *packageR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L packageL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PackageColumns = struct {
	ID                      string
	GUID                    string
	CreatedAt               string
	UpdatedAt               string
	Type                    string
	PackageHash             string
	State                   string
	Error                   string
	AppGUID                 string
	DockerImage             string
	Sha256Checksum          string
	DockerUsername          string
	DockerPasswordSalt      string
	EncryptedDockerPassword string
	EncryptionKeyLabel      string
	EncryptionIterations    string
}{
	ID:                      "id",
	GUID:                    "guid",
	CreatedAt:               "created_at",
	UpdatedAt:               "updated_at",
	Type:                    "type",
	PackageHash:             "package_hash",
	State:                   "state",
	Error:                   "error",
	AppGUID:                 "app_guid",
	DockerImage:             "docker_image",
	Sha256Checksum:          "sha256_checksum",
	DockerUsername:          "docker_username",
	DockerPasswordSalt:      "docker_password_salt",
	EncryptedDockerPassword: "encrypted_docker_password",
	EncryptionKeyLabel:      "encryption_key_label",
	EncryptionIterations:    "encryption_iterations",
}

var PackageTableColumns = struct {
	ID                      string
	GUID                    string
	CreatedAt               string
	UpdatedAt               string
	Type                    string
	PackageHash             string
	State                   string
	Error                   string
	AppGUID                 string
	DockerImage             string
	Sha256Checksum          string
	DockerUsername          string
	DockerPasswordSalt      string
	EncryptedDockerPassword string
	EncryptionKeyLabel      string
	EncryptionIterations    string
}{
	ID:                      "packages.id",
	GUID:                    "packages.guid",
	CreatedAt:               "packages.created_at",
	UpdatedAt:               "packages.updated_at",
	Type:                    "packages.type",
	PackageHash:             "packages.package_hash",
	State:                   "packages.state",
	Error:                   "packages.error",
	AppGUID:                 "packages.app_guid",
	DockerImage:             "packages.docker_image",
	Sha256Checksum:          "packages.sha256_checksum",
	DockerUsername:          "packages.docker_username",
	DockerPasswordSalt:      "packages.docker_password_salt",
	EncryptedDockerPassword: "packages.encrypted_docker_password",
	EncryptionKeyLabel:      "packages.encryption_key_label",
	EncryptionIterations:    "packages.encryption_iterations",
}

// Generated where

var PackageWhere = struct {
	ID                      whereHelperint
	GUID                    whereHelperstring
	CreatedAt               whereHelpertime_Time
	UpdatedAt               whereHelpernull_Time
	Type                    whereHelpernull_String
	PackageHash             whereHelpernull_String
	State                   whereHelperstring
	Error                   whereHelpernull_String
	AppGUID                 whereHelpernull_String
	DockerImage             whereHelpernull_String
	Sha256Checksum          whereHelpernull_String
	DockerUsername          whereHelpernull_String
	DockerPasswordSalt      whereHelpernull_String
	EncryptedDockerPassword whereHelpernull_String
	EncryptionKeyLabel      whereHelpernull_String
	EncryptionIterations    whereHelperint
}{
	ID:                      whereHelperint{field: "\"packages\".\"id\""},
	GUID:                    whereHelperstring{field: "\"packages\".\"guid\""},
	CreatedAt:               whereHelpertime_Time{field: "\"packages\".\"created_at\""},
	UpdatedAt:               whereHelpernull_Time{field: "\"packages\".\"updated_at\""},
	Type:                    whereHelpernull_String{field: "\"packages\".\"type\""},
	PackageHash:             whereHelpernull_String{field: "\"packages\".\"package_hash\""},
	State:                   whereHelperstring{field: "\"packages\".\"state\""},
	Error:                   whereHelpernull_String{field: "\"packages\".\"error\""},
	AppGUID:                 whereHelpernull_String{field: "\"packages\".\"app_guid\""},
	DockerImage:             whereHelpernull_String{field: "\"packages\".\"docker_image\""},
	Sha256Checksum:          whereHelpernull_String{field: "\"packages\".\"sha256_checksum\""},
	DockerUsername:          whereHelpernull_String{field: "\"packages\".\"docker_username\""},
	DockerPasswordSalt:      whereHelpernull_String{field: "\"packages\".\"docker_password_salt\""},
	EncryptedDockerPassword: whereHelpernull_String{field: "\"packages\".\"encrypted_docker_password\""},
	EncryptionKeyLabel:      whereHelpernull_String{field: "\"packages\".\"encryption_key_label\""},
	EncryptionIterations:    whereHelperint{field: "\"packages\".\"encryption_iterations\""},
}

// PackageRels is where relationship names are stored.
var PackageRels = struct {
	App                        string
	ResourcePackageAnnotations string
	ResourcePackageLabels      string
}{
	App:                        "App",
	ResourcePackageAnnotations: "ResourcePackageAnnotations",
	ResourcePackageLabels:      "ResourcePackageLabels",
}

// packageR is where relationships are stored.
type packageR struct {
	App                        *App                   `boil:"App" json:"App" toml:"App" yaml:"App"`
	ResourcePackageAnnotations PackageAnnotationSlice `boil:"ResourcePackageAnnotations" json:"ResourcePackageAnnotations" toml:"ResourcePackageAnnotations" yaml:"ResourcePackageAnnotations"`
	ResourcePackageLabels      PackageLabelSlice      `boil:"ResourcePackageLabels" json:"ResourcePackageLabels" toml:"ResourcePackageLabels" yaml:"ResourcePackageLabels"`
}

// NewStruct creates a new relationship struct
func (*packageR) NewStruct() *packageR {
	return &packageR{}
}

// packageL is where Load methods for each relationship are stored.
type packageL struct{}

var (
	packageAllColumns            = []string{"id", "guid", "created_at", "updated_at", "type", "package_hash", "state", "error", "app_guid", "docker_image", "sha256_checksum", "docker_username", "docker_password_salt", "encrypted_docker_password", "encryption_key_label", "encryption_iterations"}
	packageColumnsWithoutDefault = []string{"guid", "updated_at", "type", "package_hash", "state", "error", "app_guid", "docker_image", "sha256_checksum", "docker_username", "docker_password_salt", "encrypted_docker_password", "encryption_key_label"}
	packageColumnsWithDefault    = []string{"id", "created_at", "encryption_iterations"}
	packagePrimaryKeyColumns     = []string{"id"}
)

type (
	// PackageSlice is an alias for a slice of pointers to Package.
	// This should almost always be used instead of []Package.
	PackageSlice []*Package
	// PackageHook is the signature for custom Package hook methods
	PackageHook func(context.Context, boil.ContextExecutor, *Package) error

	packageQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	packageType                 = reflect.TypeOf(&Package{})
	packageMapping              = queries.MakeStructMapping(packageType)
	packagePrimaryKeyMapping, _ = queries.BindMapping(packageType, packageMapping, packagePrimaryKeyColumns)
	packageInsertCacheMut       sync.RWMutex
	packageInsertCache          = make(map[string]insertCache)
	packageUpdateCacheMut       sync.RWMutex
	packageUpdateCache          = make(map[string]updateCache)
	packageUpsertCacheMut       sync.RWMutex
	packageUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var packageBeforeInsertHooks []PackageHook
var packageBeforeUpdateHooks []PackageHook
var packageBeforeDeleteHooks []PackageHook
var packageBeforeUpsertHooks []PackageHook

var packageAfterInsertHooks []PackageHook
var packageAfterSelectHooks []PackageHook
var packageAfterUpdateHooks []PackageHook
var packageAfterDeleteHooks []PackageHook
var packageAfterUpsertHooks []PackageHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Package) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Package) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Package) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Package) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Package) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Package) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Package) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Package) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Package) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range packageAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPackageHook registers your hook function for all future operations.
func AddPackageHook(hookPoint boil.HookPoint, packageHook PackageHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		packageBeforeInsertHooks = append(packageBeforeInsertHooks, packageHook)
	case boil.BeforeUpdateHook:
		packageBeforeUpdateHooks = append(packageBeforeUpdateHooks, packageHook)
	case boil.BeforeDeleteHook:
		packageBeforeDeleteHooks = append(packageBeforeDeleteHooks, packageHook)
	case boil.BeforeUpsertHook:
		packageBeforeUpsertHooks = append(packageBeforeUpsertHooks, packageHook)
	case boil.AfterInsertHook:
		packageAfterInsertHooks = append(packageAfterInsertHooks, packageHook)
	case boil.AfterSelectHook:
		packageAfterSelectHooks = append(packageAfterSelectHooks, packageHook)
	case boil.AfterUpdateHook:
		packageAfterUpdateHooks = append(packageAfterUpdateHooks, packageHook)
	case boil.AfterDeleteHook:
		packageAfterDeleteHooks = append(packageAfterDeleteHooks, packageHook)
	case boil.AfterUpsertHook:
		packageAfterUpsertHooks = append(packageAfterUpsertHooks, packageHook)
	}
}

// One returns a single package record from the query.
func (q packageQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Package, error) {
	o := &Package{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for packages")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Package records from the query.
func (q packageQuery) All(ctx context.Context, exec boil.ContextExecutor) (PackageSlice, error) {
	var o []*Package

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Package slice")
	}

	if len(packageAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Package records in the query.
func (q packageQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count packages rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q packageQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if packages exists")
	}

	return count > 0, nil
}

// App pointed to by the foreign key.
func (o *Package) App(mods ...qm.QueryMod) appQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"guid\" = ?", o.AppGUID),
	}

	queryMods = append(queryMods, mods...)

	query := Apps(queryMods...)
	queries.SetFrom(query.Query, "\"apps\"")

	return query
}

// ResourcePackageAnnotations retrieves all the package_annotation's PackageAnnotations with an executor via resource_guid column.
func (o *Package) ResourcePackageAnnotations(mods ...qm.QueryMod) packageAnnotationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"package_annotations\".\"resource_guid\"=?", o.GUID),
	)

	query := PackageAnnotations(queryMods...)
	queries.SetFrom(query.Query, "\"package_annotations\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"package_annotations\".*"})
	}

	return query
}

// ResourcePackageLabels retrieves all the package_label's PackageLabels with an executor via resource_guid column.
func (o *Package) ResourcePackageLabels(mods ...qm.QueryMod) packageLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"package_labels\".\"resource_guid\"=?", o.GUID),
	)

	query := PackageLabels(queryMods...)
	queries.SetFrom(query.Query, "\"package_labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"package_labels\".*"})
	}

	return query
}

// LoadApp allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (packageL) LoadApp(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		if !queries.IsNil(object.AppGUID) {
			args = append(args, object.AppGUID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AppGUID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AppGUID) {
				args = append(args, obj.AppGUID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`apps`),
		qm.WhereIn(`apps.guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load App")
	}

	var resultSlice []*App
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice App")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for apps")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for apps")
	}

	if len(packageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.App = foreign
		if foreign.R == nil {
			foreign.R = &appR{}
		}
		foreign.R.Packages = append(foreign.R.Packages, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AppGUID, foreign.GUID) {
				local.R.App = foreign
				if foreign.R == nil {
					foreign.R = &appR{}
				}
				foreign.R.Packages = append(foreign.R.Packages, local)
				break
			}
		}
	}

	return nil
}

// LoadResourcePackageAnnotations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (packageL) LoadResourcePackageAnnotations(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`package_annotations`),
		qm.WhereIn(`package_annotations.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load package_annotations")
	}

	var resultSlice []*PackageAnnotation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice package_annotations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on package_annotations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for package_annotations")
	}

	if len(packageAnnotationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ResourcePackageAnnotations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &packageAnnotationR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourcePackageAnnotations = append(local.R.ResourcePackageAnnotations, foreign)
				if foreign.R == nil {
					foreign.R = &packageAnnotationR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// LoadResourcePackageLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (packageL) LoadResourcePackageLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybePackage interface{}, mods queries.Applicator) error {
	var slice []*Package
	var object *Package

	if singular {
		object = maybePackage.(*Package)
	} else {
		slice = *maybePackage.(*[]*Package)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &packageR{}
		}
		args = append(args, object.GUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &packageR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.GUID) {
					continue Outer
				}
			}

			args = append(args, obj.GUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`package_labels`),
		qm.WhereIn(`package_labels.resource_guid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load package_labels")
	}

	var resultSlice []*PackageLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice package_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on package_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for package_labels")
	}

	if len(packageLabelAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ResourcePackageLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &packageLabelR{}
			}
			foreign.R.Resource = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.GUID, foreign.ResourceGUID) {
				local.R.ResourcePackageLabels = append(local.R.ResourcePackageLabels, foreign)
				if foreign.R == nil {
					foreign.R = &packageLabelR{}
				}
				foreign.R.Resource = local
				break
			}
		}
	}

	return nil
}

// SetApp of the package to the related item.
// Sets o.R.App to related.
// Adds o to related.R.Packages.
func (o *Package) SetApp(ctx context.Context, exec boil.ContextExecutor, insert bool, related *App) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"packages\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"app_guid"}),
		strmangle.WhereClause("\"", "\"", 2, packagePrimaryKeyColumns),
	)
	values := []interface{}{related.GUID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AppGUID, related.GUID)
	if o.R == nil {
		o.R = &packageR{
			App: related,
		}
	} else {
		o.R.App = related
	}

	if related.R == nil {
		related.R = &appR{
			Packages: PackageSlice{o},
		}
	} else {
		related.R.Packages = append(related.R.Packages, o)
	}

	return nil
}

// RemoveApp relationship.
// Sets o.R.App to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Package) RemoveApp(ctx context.Context, exec boil.ContextExecutor, related *App) error {
	var err error

	queries.SetScanner(&o.AppGUID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("app_guid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.App = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Packages {
		if queries.Equal(o.AppGUID, ri.AppGUID) {
			continue
		}

		ln := len(related.R.Packages)
		if ln > 1 && i < ln-1 {
			related.R.Packages[i] = related.R.Packages[ln-1]
		}
		related.R.Packages = related.R.Packages[:ln-1]
		break
	}
	return nil
}

// AddResourcePackageAnnotations adds the given related objects to the existing relationships
// of the package, optionally inserting them as new records.
// Appends related to o.R.ResourcePackageAnnotations.
// Sets related.R.Resource appropriately.
func (o *Package) AddResourcePackageAnnotations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageAnnotation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"package_annotations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, packageAnnotationPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &packageR{
			ResourcePackageAnnotations: related,
		}
	} else {
		o.R.ResourcePackageAnnotations = append(o.R.ResourcePackageAnnotations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &packageAnnotationR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourcePackageAnnotations removes all previously related items of the
// package replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourcePackageAnnotations accordingly.
// Replaces o.R.ResourcePackageAnnotations with related.
// Sets related.R.Resource's ResourcePackageAnnotations accordingly.
func (o *Package) SetResourcePackageAnnotations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageAnnotation) error {
	query := "update \"package_annotations\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourcePackageAnnotations {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourcePackageAnnotations = nil
	}
	return o.AddResourcePackageAnnotations(ctx, exec, insert, related...)
}

// RemoveResourcePackageAnnotations relationships from objects passed in.
// Removes related items from R.ResourcePackageAnnotations (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (o *Package) RemoveResourcePackageAnnotations(ctx context.Context, exec boil.ContextExecutor, related ...*PackageAnnotation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourcePackageAnnotations {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourcePackageAnnotations)
			if ln > 1 && i < ln-1 {
				o.R.ResourcePackageAnnotations[i] = o.R.ResourcePackageAnnotations[ln-1]
			}
			o.R.ResourcePackageAnnotations = o.R.ResourcePackageAnnotations[:ln-1]
			break
		}
	}

	return nil
}

// AddResourcePackageLabels adds the given related objects to the existing relationships
// of the package, optionally inserting them as new records.
// Appends related to o.R.ResourcePackageLabels.
// Sets related.R.Resource appropriately.
func (o *Package) AddResourcePackageLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResourceGUID, o.GUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"package_labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resource_guid"}),
				strmangle.WhereClause("\"", "\"", 2, packageLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.GUID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResourceGUID, o.GUID)
		}
	}

	if o.R == nil {
		o.R = &packageR{
			ResourcePackageLabels: related,
		}
	} else {
		o.R.ResourcePackageLabels = append(o.R.ResourcePackageLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &packageLabelR{
				Resource: o,
			}
		} else {
			rel.R.Resource = o
		}
	}
	return nil
}

// SetResourcePackageLabels removes all previously related items of the
// package replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Resource's ResourcePackageLabels accordingly.
// Replaces o.R.ResourcePackageLabels with related.
// Sets related.R.Resource's ResourcePackageLabels accordingly.
func (o *Package) SetResourcePackageLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PackageLabel) error {
	query := "update \"package_labels\" set \"resource_guid\" = null where \"resource_guid\" = $1"
	values := []interface{}{o.GUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResourcePackageLabels {
			queries.SetScanner(&rel.ResourceGUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Resource = nil
		}

		o.R.ResourcePackageLabels = nil
	}
	return o.AddResourcePackageLabels(ctx, exec, insert, related...)
}

// RemoveResourcePackageLabels relationships from objects passed in.
// Removes related items from R.ResourcePackageLabels (uses pointer comparison, removal does not keep order)
// Sets related.R.Resource.
func (o *Package) RemoveResourcePackageLabels(ctx context.Context, exec boil.ContextExecutor, related ...*PackageLabel) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResourceGUID, nil)
		if rel.R != nil {
			rel.R.Resource = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("resource_guid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResourcePackageLabels {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResourcePackageLabels)
			if ln > 1 && i < ln-1 {
				o.R.ResourcePackageLabels[i] = o.R.ResourcePackageLabels[ln-1]
			}
			o.R.ResourcePackageLabels = o.R.ResourcePackageLabels[:ln-1]
			break
		}
	}

	return nil
}

// Packages retrieves all the records using an executor.
func Packages(mods ...qm.QueryMod) packageQuery {
	mods = append(mods, qm.From("\"packages\""))
	return packageQuery{NewQuery(mods...)}
}

// FindPackage retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPackage(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Package, error) {
	packageObj := &Package{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"packages\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, packageObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from packages")
	}

	if err = packageObj.doAfterSelectHooks(ctx, exec); err != nil {
		return packageObj, err
	}

	return packageObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Package) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no packages provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(packageColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	packageInsertCacheMut.RLock()
	cache, cached := packageInsertCache[key]
	packageInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			packageAllColumns,
			packageColumnsWithDefault,
			packageColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(packageType, packageMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"packages\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"packages\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into packages")
	}

	if !cached {
		packageInsertCacheMut.Lock()
		packageInsertCache[key] = cache
		packageInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Package.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Package) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	packageUpdateCacheMut.RLock()
	cache, cached := packageUpdateCache[key]
	packageUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			packageAllColumns,
			packagePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update packages, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"packages\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, packagePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, append(wl, packagePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update packages row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for packages")
	}

	if !cached {
		packageUpdateCacheMut.Lock()
		packageUpdateCache[key] = cache
		packageUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q packageQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for packages")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PackageSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"packages\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, packagePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in package slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all package")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Package) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no packages provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(packageColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	packageUpsertCacheMut.RLock()
	cache, cached := packageUpsertCache[key]
	packageUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			packageAllColumns,
			packageColumnsWithDefault,
			packageColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			packageAllColumns,
			packagePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert packages, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(packagePrimaryKeyColumns))
			copy(conflict, packagePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"packages\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(packageType, packageMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(packageType, packageMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert packages")
	}

	if !cached {
		packageUpsertCacheMut.Lock()
		packageUpsertCache[key] = cache
		packageUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Package record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Package) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Package provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), packagePrimaryKeyMapping)
	sql := "DELETE FROM \"packages\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for packages")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q packageQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no packageQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from packages")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for packages")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PackageSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(packageBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"packages\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, packagePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from package slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for packages")
	}

	if len(packageAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Package) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPackage(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PackageSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PackageSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), packagePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"packages\".* FROM \"packages\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, packagePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PackageSlice")
	}

	*o = slice

	return nil
}

// PackageExists checks if the Package row exists.
func PackageExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"packages\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if packages exists")
	}

	return exists, nil
}
